---
title: java常见面试题
mathjax: true
date: 2018-03-15 10:40:55
tags: [java]
category: [工作]
---

#### 1. 面向对象特征

<!--more-->

封装，继承，多态和抽象

1. 封装
   封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改
   变它内部的数据。在 Java 当中，有 3 种修饰符： public， private 和 protected。每一种修饰符
   给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。
   下面列出了使用封装的一些好处：
   - 通过隐藏对象的属性来保护对象内部的状态。
   - 提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。
   - 禁止对象之间的不良交互提高模块化
2. 继承：给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用性，也可以在不修改类的情况下给现存的类添加新特性。
3. 多态：是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作可以应用到其他类型的值上面。
4. 抽象：是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。 Java 支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。

#### 2. final, finally, finalize 的区别

1. final修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载。
2. finally在异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。
3. finalize方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。

#### 3. int 和 Integer 有什么区别

int 是基本数据类型
Integer是其包装类，注意是一个类。
为什么要提供包装类呢？？？
一是为了在各种类型间转化，通过各种方法的调用。否则 你无法直接通过变量转化。
比如，现在int要转为String

```java
int a=0;
String result=Integer.toString(a);
```

在java中包装类，比较多的用途是用在于各种数据类型的转化中。

```java
int num=Integer.valueOf("12");// 返回包装类型
int num2=Integer.parseInt("12"); //返回基本数据类型
```

再举例下。比如我现在要用泛型

```java
List<Integer> nums;
```

这里<>需要类。如果你用int。它会报错的。

#### 4. 重载和重写的区别

**override（重写）**

1. 方法名、参数、返回值相同。

2. 子类方法不能缩小父类方法的访问权限。

3. 子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。

4. 存在于父类和子类之间。

5. 方法被定义为final不能被重写。

**overload（重载）**

1. 参数类型、个数、顺序至少有一个不相同。

2. 不能重载只有返回值不同的方法名。

3. 存在于父类和子类、同类中。

#### 5. 抽象类和接口有什么区别

总结：接口没有私有变量，接口可以用于实现多继承，实现接口必须实现所有其中定义的方法

接口是公开的，里面不能有私有的方法或变量，是用于让别人使用的，而抽象类是可以有私有方法或私有变量的，
另外，实现接口的一定要实现接口里定义的所有方法，而实现抽象类可以有选择地重写需要用到的方法，一般的应用里，最顶级的是接口，然后是抽象类实现接口，最后才到具体类实现。
还有，接口可以实现多重继承，而一个类只能继承一个超类，但可以通过继承多个接口实现多重继承，接口还有标识（里面没有任何方法，如Remote接口）和数据共享（里面的变量全是常量）的作用。

#### 6. 说说反射的用途及实现

Java 反射机制在程序**运行时**，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 **动态的获取信息** 以及 **动态调用对象的方法** 的功能称为 **java 的反射机制**。

Java反射机制主要提供了以下功能：在运行时构造一个类的对象；判断一个类所具有的成员变量和方法；调用一个对象的方法；生成动态代理。反射最大的应用就是框架

Java反射的主要功能：

- 确定一个对象的类
- 取出类的modifiers,数据成员,方法,构造器,和超类.
- 找出某个接口里定义的常量和方法说明.
- 创建一个类实例,这个实例在运行时刻才有名字(运行时间才生成的对象).
- 取得和设定对象数据成员的值,如果数据成员名是运行时刻确定的也能做到.
- 在运行时刻调用动态对象的方法.
- 创建数组,数组大小和类型在运行时刻才确定,也能更改数组成员的值.

反射的应用很多，很多框架都有用到

spring 的 ioc/di 也是反射….
javaBean和jsp之间调用也是反射….
struts的 FormBean 和页面之间…也是通过反射调用….
JDBC 的 classForName()也是反射…..
hibernate的 find(Class clazz) 也是反射….

反射还有一个不得不说的问题，就是性能问题，大量使用反射系统性能大打折扣。怎么使用使你的系统达到最优就看你系统架构和综合使用问题啦，这里就不多说了。

#### 7. HTTP 请求的 GET 与 POST 方式的区别

GET方法会把名值对追加在请求的URL后面。因为URL对字符数目有限制，进而限制了用在客户端请求的参数值的数目。并且请求中的参数值是可见的，因此，敏感信息不能用这种方式传递。

POST方法通过把请求参数值放在请求体中来克服GET方法的限制，因此，可以发送的参数的数目是没有限制的。最后，通过POST请求传递的敏感信息对外部客户端是不可见的。

具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案

#### 8.cookie 和session 的区别：

1、cookie数据存放在客户的浏览器上，session数据放在服务器上。

2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
   考虑到安全应当使用session。

3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
   考虑到减轻服务器性能方面，应当使用COOKIE。

4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

5、所以个人建议：
   将登陆信息等重要信息存放为SESSION
   其他信息如果需要保留，可以放在COOKIE中

#### JDBC 流程

**1、 加载JDBC驱动程序：**
在连接数据库之前，首先要加载想要连接的数据库的驱动到JVM（Java虚拟机），
这通过java.lang.Class类的静态方法forName(String className)实现。

**2、 提供JDBC连接的URL**

- 连接URL定义了连接数据库时的协议、子协议、数据源标识。
- 书写形式：协议：子协议：数据源标识

协议：在JDBC中总是以jdbc开始 子协议：是桥连接的驱动程序或是数据库管理系统名称。
数据源标识：标记找到数据库来源的地址与连接端口。

**3、创建数据库的连接**

- 要连接数据库，需要向java.sql.DriverManager请求并获得Connection对象， 该对象就代表一个数据库的连接。
- 使用DriverManager的getConnectin(String url , String username , String password )方法传入指定的欲连接的数据库的路径、数据库的用户名和 密码来获得。

**4、 创建一个Statement**

要执行SQL语句，必须获得java.sql.Statement实例，Statement实例分为以下3 种类型：
1、执行静态SQL语句。通常通过Statement实例实现。
2、执行动态SQL语句。通常通过PreparedStatement实例实现。
3、执行数据库存储过程。通常通过CallableStatement实例实现。

**5、执行SQL语句**
Statement接口提供了三种执行SQL语句的方法：executeQuery 、executeUpdate 和execute
1、ResultSet executeQuery(String sqlString)：执行查询数据库的SQL语句 ，返回一个结果集（ResultSet）对象。
2、int executeUpdate(String sqlString)：用于执行INSERT、UPDATE或 DELETE语句以及SQL DDL语句，如：CREATE TABLE和DROP TABLE等
3、execute(sqlString):用于执行返回多个结果集、多个更新计数或二者组合的 语句。 具体实现的代码：

**6、处理结果**
两种情况：
1、执行更新返回的是本次操作影响到的记录数。
2、执行查询返回的结果是一个ResultSet对象。

**7、关闭JDBC对象**
操作完成以后要把所有使用的JDBC对象全都关闭，以释放JDBC资源，关闭顺序和声 明顺序相反：
1、关闭记录集
2、关闭声明
3、关闭连接对象

#### MVC 设计思想

MVC就是
M:Model 模型
V:View 视图
C:Controller 控制器
模型就是封装业务逻辑和数据的一个一个的模块,控制器就是调用这些模块的(java中通常是用Servlet来实现,框架的话很多是用Struts2来实现这一层),视图就主要是你看到的,比如JSP等.
当用户发出请求的时候,控制器根据请求来选择要处理的业务逻辑和要选择的数据,再返回去把结果输出到视图层,这里可能是进行重定向或转发等.

#### equals 与 == 的区别

值类型（int,char,long,boolean等）都是用==判断相等性。对象引用的话，==判断引用所指的对象是否是同一个。

equals是Object的成员函数，有些类会覆盖（override）这个方法，用于判断对象的等价性。例如String类，两个引用所指向的String都是”abc”，但可能出现他们实际对应的对象并不是同一个（和jvm实现方式有关），因此用==判断他们可能不相等，但用equals判断一定是相等的。

### 集合

#### List 和 Set 区别

List,Set都是继承自Collection接口

List特点：元素有放入顺序，元素可重复

Set特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉

（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的，加入Set 的Object必须定义equals()方法 ，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。）

Set和List对比：

Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。

List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。

#### List 和 Map 区别

List是对象集合，允许对象重复。

Map是键值对的集合，不允许key重复。

#### Arraylist 与 LinkedList 区别

**Arraylist**：

优点：ArrayList是实现了基于动态数组的数据结构,因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。

缺点：因为地址连续， ArrayList要移动数据，所以插入和删除操作效率比较低。

**LinkedList**：

优点：LinkedList基于链表的数据结构,地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址，对于新增和删除操作add和remove，LinedList比较占优势。LinkedList 适用于要头尾操作或插入指定位置的场景

缺点：因为LinkedList要移动指针,所以查询操作性能比较低。

**适用场景分析：**

当需要对数据进行顺序访问的情况下选用ArrayList，当需要对数据进行多次增加删除修改时采用LinkedList。

#### ArrayList 与 Vector 区别

ArrayList和Vector都是用数组实现的，主要有这么三个区别：

1. Vector是多线程安全的，线程安全就是说多线程访问同一代码，不会产生不确定的结果。而ArrayList不是，这个可以从源码中看出，Vector类中的方法很多有synchronized进行修饰，这样就导致了Vector在效率上无法与ArrayList相比；
2. 两个都是采用的线性连续空间存储元素，但是当空间不足的时候，两个类的增加方式是不同。
3. Vector可以设置增长因子，而ArrayList不可以。
4. Vector是一种老的动态数组，是线程同步的，效率很低，一般不赞成使用。

**适用场景分析**：

1. Vector是线程同步的，所以它也是线程安全的，而ArrayList是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用ArrayList效率比较高。
2. 如果集合中的元素的数目大于目前集合数组的长度时，在集合中使用数据量比较大的数据，用Vector有一定的优势。

#### HashMap 和 Hashtable 的区别

1.hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和containsKey（）方法。

2.hashTable同步的，而HashMap是非同步的，效率上比hashTable要高。

3.hashMap允许空键值，而hashTable不允许。

注意：TreeMap：非线程安全基于红黑树实现。TreeMap没有调优选项，因为该树总处于平衡状态。

Treemap：适用于按自然顺序或自定义顺序遍历键(key)。

#### HashSet 和 HashMap 区别

set是线性结构，set中的值不能重复，hashset是set的hash实现，hashset中值不能重复是用hashmap的key来实现的。

map是键值对映射，可以空键空值。HashMap是Map接口的hash实现，key的唯一性是通过key值hash值的唯一来确定，value值是则是链表结构。

他们的共同点都是hash算法实现的唯一性，他们都不能持有基本类型，只能持有对象

#### HashMap 和 ConcurrentHashMap 的区别

ConcurrentHashMap是线程安全的HashMap的实现。

（1）ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的syn关键字锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。

（2）HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。

#### ConcurrentHashMap 的工作原理及代码实现

HashTable里使用的是synchronized关键字，这其实是对对象加锁，锁住的都是对象整体，当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。

ConcurrentHashMap引入了分割(Segment)，在put方法中，会根据hash(paramK.hashCode())来决定具体存放进哪个Segment，如果查看Segment的put操作，我们会发现内部使用的同步机制是基于lock操作的，这样就可以对Map的一部分（Segment）进行上锁，这样影响的只是将要放入同一个Segment的元素的put操作，保证同步的时候，锁住的不是整个Map（HashTable就是这么做的），相对于HashTable提高了多线程环境下的性能，因此HashTable已经被淘汰了。

### 线程

#### 创建线程的方式及实现

Java中创建线程主要有三种方式：

**一、继承Thread类创建线程类**

（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。

（2）创建Thread子类的实例，即创建了线程对象。

（3）调用线程对象的start()方法来启动该线程。

**二、通过Runnable接口创建线程类**

（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。

（2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。

（3）调用线程对象的start()方法来启动该线程。

**三、通过Callable和FutureTask创建线程**

（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。

（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。

（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。

（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值

**创建线程的三种方式的对比**

采用实现Runnable、Callable接口的方式创见多线程时，优势是：

线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。

在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。

劣势是：

编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。

使用继承Thread类的方式创建多线程时优势是：

编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。

劣势是：

线程类已经继承了Thread类，所以不能再继承其他父类。

#### sleep() 、join（）、yield（）有什么区别

**1、sleep()方法**

在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。 让其他线程有机会继续执行，但它并不释放对象锁。也就是如果有Synchronized同步块，其他线程仍然不能访问共享数据。注意该方法要捕获异常

比如有两个线程同时执行(没有Synchronized)，一个线程优先级为MAX_PRIORITY，另一个为MIN_PRIORITY，如果没有Sleep()方法，只有高优先级的线程执行完成后，低优先级的线程才能执行；但当高优先级的线程sleep(5000)后，低优先级就有机会执行了。总之，sleep()可以使低优先级的线程得到执行的机会，当然也可以让同优先级、高优先级的线程有执行的机会。

**2、yield()方法**

yield()方法和sleep()方法类似，也不会释放“锁标志”，区别在于，它没有参数，即yield()方法只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行，另外yield()方法只能使同优先级或者高优先级的线程得到执行机会，这也和sleep()方法不同。

**线程的sleep()方法和yield()方法有什么区别？**

答： ① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会； ② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态； ③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常； ④ sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。

**3、join()方法**

Thread的非静态方法join()让一个线程B“加入”到另外一个线程A的尾部。在A执行完毕之前，B不能工作。

#### 讲讲线程池的实现原理

主要是ThreadPoolExecutor的实现原理，在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。

#### 线程池的几种方式

newFixedThreadPool(int nThreads)
创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程

newCachedThreadPool()
创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制

newSingleThreadExecutor()
这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行

newScheduledThreadPool(int corePoolSize)
创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。

#### 线程的生命周期

新建(New)、就绪（Runnable）、运行（Running）、 阻塞(Blocked)和死亡(Dead)5种状态

(1)生命周期的五种状态

**新建（new Thread）**
当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。
例如：Thread t1=new Thread();

**就绪（runnable）**
线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源。例如：t1.start();

**运行（running）**
线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。

**死亡（dead）**
当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。

自然终止：正常运行run()方法后终止

异常终止：调用stop()方法让一个线程终止运行

**堵塞（blocked）**
由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。

正在睡眠：用sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。

正在等待：调用wait()方法。（调用motify()方法回到就绪状态）

被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复）

### 锁机制

#### 说说线程安全问题

线程安全是指要控制多个线程对某个资源的有序访问或修改，而在这些线程之间没有产生冲突。
在Java里，线程安全一般体现在两个方面：
1、多个thread对同一个java实例的访问（read和modify）不会相互干扰。

它主要体现在关键字synchronized。如ArrayList和Vector，HashMap和Hashtable（后者每个方法前都有synchronized关键字）。如果你在interator一个List对象时，其它线程remove一个element，问题就出现了。
2、每个线程都有自己的字段，而不会在多个线程之间共享。

它主要体现在java.lang.ThreadLocal类，而没有Java关键字支持，如像static、transient那样。

#### 悲观锁 乐观锁

乐观锁 悲观锁是一种思想。可以用在很多方面。

比如数据库方面。
悲观锁就是for update（锁定查询的行）
乐观锁就是 version字段（比较跟上一次的版本号，如果一样则更新，如果失败则要重复读-比较-写的操作。）

JDK方面：
悲观锁就是sync
乐观锁就是原子类（内部使用CAS实现）

本质来说，就是悲观锁认为总会有人抢我的。乐观锁就认为，基本没人抢。

#### CAS 乐观锁

乐观锁是一种思想，即认为读多写少，遇到并发写的可能性比较低，所以采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。

CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。CAS顶多算是乐观锁写那一步操作的一种实现方式罢了，不用CAS自己加锁也是可以的。

#### ABA 问题

ABA：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A，当前线程的CAS操作无法分辨当前V值是否发生过变化。

乐观锁（Optimistic Lock）：每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。

乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。

#### 1.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？

Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。Java 源文件被编译成能被 Java 虚拟机执行的字节码文件。

 Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。

 Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。

#### 2.JDK和JRE的区别是什么？

JDK: java开发工具包,包含了JRE、编译器和其它工具（如：javaDOc、java调试器)

JRE: java运行环境,包含java虚拟机和java程序所需的核心类库。

如果只是想跑java程序，那么只需安装JRE，如果要写java程序并且运行，那就需要JDK了。

#### 3."static"关键字是什么意思？Java中是否可以覆盖一个private或者是static的方法？

如果一个类的变量或者方法前面有**static**修饰，那么表明这个方法或者变量属于这个类，也就是说可以在不创建对象的情况下直接使用

 当父类的方法被**private**修饰时，表明该方法为父类私有，对其他任何类都是不可见的，因此如果子类定了一个与父类一样的方法，这对于子类来说相当于是一个新的私有方法，且如果要进行向上转型，然后去调用该“覆盖方法”，会产生编译错误

#### 4.Java支持的基本数据类型有哪些？什么是自动拆装箱？

java支持的基本数据类型有以下9种:byte,shot,int,long,float,double,char,boolean,void.

自动拆装箱是java从jdk1.5引用，目的是将原始类型自动的装换为相对应的对象，也可以逆向进行，即拆箱。这也体现java中一切皆对象的宗旨。

所谓自动装箱就是将原始类型自动的转换为对应的对象，而拆箱就是将对象类型转换为基本类型。java中的自动拆装箱通常发生在变量赋值的过程中。

#### 5. 重写和重载是什么?

**重写**，发生在子类与父类之间，表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。

**重载**是指在一个类中，可以有多个相同名称的方法，但是他们的参数列表的个数或类型不同，当调用该方法时，根据传递的参数类型调用对应参数列表的方法。当参数列表相同但返回值不同时，将会出现编译错误，这并不是重载，因为jvm无法根据返回值类型来判断应该调用哪个方法。

#### 6.Java支持多继承么？如果不支持，如何实现?
在java中是单继承的，也就是说一个类只能继承一个父类。

java中实现多继承有两种方式,一是接口，而是内部类.

### 7.什么是值传递和引用传递？java中是值传递还是引用传递，还是都有?

**值传递** 就是在方法调用的时候，实参是将自己的一份拷贝赋给形参，在方法内，对该参数值的修改不影响原来实参，常见的例子就是刚开始学习c语言的时候那个交换方法的例子了。

**引用传递** 是在方法调用的时候，实参将自己的地址传递给形参，此时方法内对该参数值的改变，就是对该实参的实际操作。

在java中基本数据类型的传递是值传递，对象的传递是引用传递

#### 8.接口和抽象类的区别是什么?

区别：

1. 接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。

2. 类可以实现很多个接口，但是只能继承一个抽象类

3. 类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。

4. 抽象类可以在不提供接口方法实现的情况下实现接口。

5. Java 接口中声明的变量默认都是 final 的。抽象类可以包含非 final 的变量。

6. Java 接口中的成员函数默认是 public 的。抽象类的成员函数可以是 private，protected 或者是 public 。

7. 接口是绝对抽象的，不可以被实例化(java 8已支持在接口中实现默认的方法)。抽象类也不可以被实例化，但是，如果它包含 main 方法的话是可以被调用的。

####9.构造器（constructor）是否可被重写（override）?
构造方法不能被子类继承，所以是不能被子类重写的，但是构造方法可以重载，也就是说一个类可以有多个构造方法。

#### 10.Math.round(11.5) 等于多少? Math.round(-11.5)等于多少?
Math.round(11.5)==12 Math.round(-11.5)==-11 round 方法返回与参数 最接近的长整数，参数加 1/2 后求其 floor.

#### 11. String, StringBuffer StringBuilder的区别。

String 的长度是不可变的；

StringBuffer的长度是可变的，如果你对字符串中的内容经常进行操作，特别是内容要修改时，那么使用 StringBuffer，如果最后需要 >String，那么使用 StringBuffer 的 toString() 方法；线程安全；

StringBuilder 是从 JDK 5 开始，为StringBuffer该类补充了一个单个线程使用的等价类；通常应该优先使用 StringBuilder 类，因为它支持所有相同的操作，但由于它不执行同步（线程不安全），所以速度更快。

使用字符串的时候要特别小心，如果对一个字符串要经常改变的话，就一定不要用String,否则会创建许多无用的对象出来.

#### 12.JVM内存分哪几个区，每个区的作用是什么?
java虚拟机主要分为以下五个区: 方虚本程堆

**方法区：**

1. 有时候也称为**永久代**，在该区内很少发生垃圾回收，但是并不代表不发生GC，在这里进行的GC主要是对方法区里的常量池和对类型的卸载
2. 方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。
3. 该区域是被线程共享的。
4. 方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。

**虚拟机栈:**

1. 虚拟机栈也就是我们平常所称的**栈内存**,它为java方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。
2. 虚拟机栈是线程私有的，它的生命周期与线程相同。
3. 局部变量表里存储的是基本数据类型、returnAddress类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定
4. 操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式
5. 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接.动态链接就是将常量池中的符号引用在运行期转化为直接引用。

**本地方法栈**

本地方法栈和虚拟机栈类似，只不过本地方法栈为Native方法服务。

**堆**

 java堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作。

**程序计数器**

内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内存区域是唯一一个java虚拟机规范没有规定任何out of memory情况的区域。

### 13.如和判断一个对象是否存活?(或者GC对象的判定方法)

判断一个对象是否存活有两种方法:

 **引用计数法**

所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收.

引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象A引用对象B，对象B又引用者对象A，那么此时A,B对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。

2.**可达性算法**(引用链法)

该算法的思想是：从一个被称为**GC Roots**的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。

在java中可以作为GC Roots的对象有以下几种:

虚拟机栈中引用的对象
方法区类静态属性引用的对象
方法区常量池引用的对象
本地方法栈JNI引用的对象

### 14.简述java垃圾回收机制?

在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。

### 15.java中垃圾回收的方法有哪些?

 1. **标记-清除:**

     这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想就是标记哪些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题：1.效率不高，标记和清除的效率都很低；2.会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次GC动作。

 2. **复制算法:**

     为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。但是这种方式，内存的代价太高，每次基本上都要浪费一般的内存。

     于是将该算法进行了改进，内存区域不再是按照1：1去划分，而是将内存划分为8:1:1三部分，较大那份内存交Eden区，其余是两块较小的内存区叫Survior区。每次都会优先使用Eden区，若Eden区满，就将对象复制到第二块内存区上，然后清除Eden区，如果此时存活的对象太多，以至于Survivor不够时，会将这些对象通过分配担保机制复制到老年代中。(java堆又分为新生代和老年代)

 3. **标记-整理**

     该算法主要是为了解决标记-清除，产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候先将可回收对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。

4. **分代收集** 

     现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用**复制**算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用**标记-整理** 或者 **标记-清除**。

#### 16.java内存模型

java内存模型(JMM)是线程间通信的控制机制.JMM定义了主内存和线程之间抽象关系。线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java内存模型的抽象示意图如下：

#### 17.java类加载过程?

 java类加载需要经历以下5个过程：加验准解初

**加载（通过名字获取类并生成class文件），**

**验证（保证字节流不危害到虚拟机），**

**准备（为静态变量分配内存），**

**解析（符号引用变为直接引用），**

**初始化（之前的都由虚拟机控制，这一步才真正执行类中的java代码）**

 **加载**

 加载时类加载的第一个过程，在这个阶段，将完成一下三件事情：

 1. 通过一个类的全限定名获取该类的二进制流。
   
 2. 将该二进制流中的静态存储结构转化为方法去运行时数据结构。
 3. 在内存中生成该类的Class对象，作为该类的数据访问入口。

 **验证**

验证的目的是为了确保Class文件的字节流中的信息不会危害到虚拟机.在该阶段主要完成以下四钟验证:

 1. 文件格式验证：验证字节流是否符合Class文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型.
   
 2. 元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。
   
 3. 字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。
   
 4. 符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。

 **准备**

准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。

**解析** 

该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。

**初始化**

初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。

#### 18.简述java类加载机制?
虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的java类型。

####19.类加载器双亲委派模型机制？
当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。

#### 20.什么是类加载器，类加载器有哪些?

实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。

主要有一下四种类加载器:

1. 启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。
2. 扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。

3. 系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。
4. 用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。

#### **21.简述java内存分配与回收策率以及Minor GC和Major GC**

1. 对象优先在堆的Eden区分配。

2. 大对象直接进入老年代.

3. 长期存活的对象将直接进入老年代.



当Eden区没有足够的空间进行分配时，虚拟机会执行一次Minor GC.Minor Gc通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生Gc的频率较高，回收速度比较快;Full Gc/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC,但是通过配置，可以在Full GC之前进行一次Minor GC这样可以加快老年代的回收速度。

**Minor GC条件**

当Eden区空间不足以继续分配对象，发起Minor GC。

**Full GC条件**

1. 调用System.gc时，系统建议执行Full GC，但是不必然执行
2. 老年代空间不足（通过Minor GC后进入老年代的大小大于老年代的可用内存）
3. 方法区空间不足






### **22.HashMap的工作原理是什么?**

HashMap内部是通过一个数组实现的，只是这个数组比较特殊，数组里存储的元素是一个Entry实体(jdk 8为Node)，这个Entry实体主要包含key、value以及一个指向自身的next指针。HashMap是基于hashing实现的，当我们进行put操作时，根据传递的key值得到它的hashcode，然后再用这个hashcode与数组的长度进行模运算，得到一个int值，就是Entry要存储在数组的位置（下标）；当通过get方法获取指定key的值时，会根据这个key算出它的hash值（数组下标），根据这个hash值获取数组下标对应的Entry，然后判断Entry里的key，hash值或者通过equals()比较是否与要查找的相同，如果相同，返回value，否则的话，遍历该链表（有可能就只有一个Entry，此时直接返回null），直到找到为止，否则返回null。

HashMap之所以在每个数组元素存储的是一个链表，是为了解决hash冲突问题，当两个对象的hash值相等时，那么一个位置肯定是放不下两个值的，于是hashmap采用链表来解决这种冲突，hash值相等的两个元素会形成一个链表。

### **23.HashMap与HashTable的区别是什么?**

1. HashTable基于Dictionary类，而HashMap是基于AbstractMap。Dictionary是任何可将键映射到相应值的类的抽象父类，而AbstractMap是基于Map接口的实现，它以最大限度地减少实现此接口所需的工作。

2. HashMap的key和value都允许为null，而Hashtable的key和value都不允许为null。HashMap遇到key为null的时候，调用putForNullKey方法进行处理，而对value没有处理；Hashtable遇到null，直接返回NullPointerException。

3. Hashtable是同步的，而HashMap是非同步的，但是我们也可以通过Collections.synchronizedMap(hashMap),使其实现同步。

### 24.CorrentHashMap的工作原理?

**jdk 1.6版:** ConcurrenHashMap可以说是HashMap的升级版，ConcurrentHashMap是线程安全的，但是与Hashtablea相比，实现线程安全的方式不同。Hashtable是通过对hash表结构进行锁定，是阻塞式的，当一个线程占有这个锁时，其他线程必须阻塞等待其释放锁。ConcurrentHashMap是采用分离锁的方式，它并没有对整个hash表进行锁定，而是局部锁定，也就是说当一个线程占有这个局部锁时，不影响其他线程对hash表其他地方的访问。

具体实现:ConcurrentHashMap内部有一个Segment<K,V>数组,该Segment对象可以充当锁。Segment对象内部有一个HashEntry<K,V>数组，于是每个Segment可以守护若干个桶(HashEntry),每个桶又有可能是一个HashEntry连接起来的链表，存储发生碰撞的元素。

 每个ConcurrentHashMap在默认并发级下会创建包含16个Segment对象的数组，每个数组有若干个桶，当我们进行put方法时，通过hash方法对key进行计算，得到hash值，找到对应的segment，然后对该segment进行加锁，然后调用segment的put方法进行存储操作，此时其他线程就不能访问当前的segment，但可以访问其他的segment对象，不会发生阻塞等待。

 **jdk 1.8版** 在jdk 8中，ConcurrentHashMap不再使用Segment分离锁，而是采用一种乐观锁CAS算法来实现同步问题，但其底层还是“数组+链表->红黑树”的实现。

### 27.Array和ArrayList有何区别？什么时候更适合用Array？

1. Array可以容纳基本类型和对象，而ArrayList只能容纳对象。

2. Array是指定大小的，而ArrayList大小是固定的

### 28.哪些集合类提供对元素的随机访问？

ArrayList、HashMap、TreeMap和HashTable类提供对元素的随机访问。

### 29.HashSet的底层实现是什么?

通过看源码知道HashSet的实现是依赖于HashMap的，HashSet的值都是存储在HashMap中的。在HashSet的构造法中会初始化一个HashMap对象，HashSet不允许值重复，因此，HashSet的值是作为HashMap的key存储在HashMap中的，当存储的值已经存在时返回false。

### 30.LinkedHashMap的实现原理?

LinkedHashMap也是基于HashMap实现的，不同的是它定义了一个Entry header，这个header不是放在Table里，它是额外独立出来的。LinkedHashMap通过继承hashMap中的Entry,并添加两个属性Entry before,after,和header结合起来组成一个双向链表，来实现按插入顺序或访问顺序排序。LinkedHashMap定义了排序模式accessOrder，该属性为boolean型变量，对于访问顺序，为true；对于插入顺序，则为false。一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。

### 33.Thread 类中的start() 和 run() 方法有什么区别？

start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。

### 35.Java中有哪几种锁?

**自旋锁:** 自旋锁在JDK1.6之后就默认开启了。基于之前的观察，共享数据的锁定状态只会持续很短的时间，为了这一小段时间而去挂起和恢复线程有点浪费，所以这里就做了一个处理，让后面请求锁的那个线程在稍等一会，但是不放弃处理器的执行时间，看看持有锁的线程能否快速释放。为了让线程等待，所以需要让线程执行一个忙循环也就是自旋操作。

在jdk6之后，引入了自适应的自旋锁，也就是等待的时间不再固定了，而是由上一次在同一个锁上的自旋时间及锁的拥有者状态来决定

**偏向锁:** 在JDK1.之后引入的一项锁优化，目的是消除数据在无竞争情况下的同步原语。进一步提升程序的运行性能。 偏向锁就是偏心的偏，意思是这个锁会偏向第一个获得他的线程，如果接下来的执行过程中，该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。偏向锁可以提高带有同步但无竞争的程序性能，也就是说他并不一定总是对程序运行有利，如果程序中大多数的锁都是被多个不同的线程访问，那偏向模式就是多余的，在具体问题具体分析的前提下，可以考虑是否使用偏向锁。

**轻量级锁:** 为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。

### 37.ThreadLocal理解

ThreadLocal是一个创建——线程局部变量的类。通常情况下我们创建的变量,可以被多个线程访问并修改，通过ThreadLocal创建的变量只能被当前线程访问。

**ThreadLocal内部实现**

ThreadLocal提供了set和get方法.
 set方法会先获取当前线程,然后用当前线程作为句柄,获取ThreadLocaMap对象,并判断该对象是否为空,如果为空则创建一个,并设置值,不为空则直接设置值。

#### 38. synchronized和lock的区别？

- 主要相同点：Lock能完成synchronized所实现的所有功能。
- 主要不同点：Lock有比synchronized更精确的线程予以和更好的性能。

1. synchronized会自动释放锁，但是Lock一定要求程序员手工释放，并且必须在finally从句中释放。
2. synchronized修饰方法时,表示同一个对象在不同的线程中,表现为同步队列,如果实例化不同的对象,那么synchronized就不会出现同步效果了。

具体用法：

```java
Lock lock = new ReentrantLock
if(lock.trylock){
try{
xxxx
}
catch(Exception e){
e.printStackTrace()
}
finally{
lock.unlock();
}
}
```



#### 39. 单例模式

单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 

#### 40.数据库的四种隔离等级

* 未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据

* 提交读(Read Committed)：写禁止读写，只限制同一数据写事务禁止其它读写事务。解决”脏读”和”更新丢失”。Oracle等多数数据库默认都是该级别 (不重复读)

* 可重复读(Repeated Read)：读写禁止其它读写。限制同一数据写事务禁止其他读写事务，读事务禁止其它写事务(允许读)。InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读

* 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞

**① 脏读:** 脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。

**②不可重复读**：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。

**④ 幻读:**事务 T1 读取一条指定的 Where 子句所返回的结果集，然后 T2 事务新插入一行记录，这行记录恰好可以满足T1 所使用的查询条件。然后 T1 再次对表进行检索，但又看到了 T2 插入的数据。 （和可重复读类似，但是事务 T2 的数据操作仅仅是插入和删除，不是修改数据，读取的记录数量前后不一致）

#### 倒排索引

#### 是否可以在static环境中访问非static变量？

static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。

#### Java支持的数据类型有哪些？什么是自动拆装箱？

Java语言支持的8种基本数据类型是：

byte、short、int、long、float、double、boolean、char

自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。

#### 概括的解释下线程的几种可用状态。线程状态

1. 新建
2. 可运行：新建后调用了start方法，放入线程池等待调度，获取cpu使用权
3. 运行：可运行的线程获取了cpu时间片
4. 阻塞：线程因某种原因放弃了cpu时间片
   1）同步阻塞：因为没有获取到同步锁而阻塞
   2）等待阻塞：调用了wait方法，等待notify方法解出阻塞状态
   3）其他阻塞：sleep方法之类的，等sleep超时之后恢复
5. 死亡：run结束，或异常退出run，死亡不可再生

#### 同步方法和同步代码块的区别是什么？

同步方法默认用this或者当前类class对象作为锁；

同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；

同步方法使用关键字 synchronized修饰方法，而同步代码块主要是修饰需要进行同步的代码，用   synchronized（object）{代码内容}进行修饰；

#### 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？

监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。

#### 什么是死锁(deadlock)？

**死锁** **:**是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种**互相等待**的现象,若无**外力**作用,它们都将无法推进下去

（1） **互斥条件**：一个资源每次只能被一个进程使用。  

（2） **请求与保持条件**：一个进程因请求资源而阻塞时，对已获得的资源保持不放。  

（3） **不可抢占**:进程已获得的资源，在末使用完之前，不能强行剥夺。  

（4） **循环等待**:有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

#### 如何确保N个线程可以访问N个资源同时又不导致死锁？

使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。

#### 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？

一：快速失败（fail—fast）

在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的结构进行了修改（增加、删除），则会抛出Concurrent Modification Exception。

原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果结构发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。

注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。

​      场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。

​    二：安全失败（fail—safe）

​      采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。

​      原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。

​      缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。

​          场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。

####数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？

1. Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。
2. Array大小是固定的，ArrayList的大小是动态变化的。
3. ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。
   对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。

#### 什么是优先级队列

优先级队列中的元素可以按照任意的顺序插入，却总是按照排序的顺序进行检索。无论何时调用remove方法，总会获得当前优先级队列中的最小元素，但并不是对所有元素都排序。它是采用了堆（一个可以自我调整的二叉树），执行增加删除操作后，可以让最小元素移动到根。

#### 串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？

吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。而串行收集器对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。

#### 数据库四个特性

1. 原子性（Atomicity）

　　原子性是指事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败。比如在同一个事务中的SQL语句，要么全部执行成功，要么全部执行失败。

　　回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

2. 一致性（Consistency）

　　事务必须使数据库从一个一致性状态变换到另外一个一致性状态。以转账为例子，A向B转账，假设转账之前这两个用户的钱加起来总共是2000，那么A向B转账之后，不管这两个账户怎么转，A用户的钱和B用户的钱加起来的总额还是2000，这个就是事务的一致性。

3. 隔离性（Isolation）

　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

　　即要达到这么一种效果：对于任意两个并发的事务 T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。

4. 持久性（Durability）

　　一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。

　　可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。

什么情况下不推荐使用索引？
1) 数据唯一性差（一个字段的取值只有几种时）的字段不要使用索引

比如性别，只有两种可能数据。意味着索引的二叉树级别少，多是平级。这样的二叉树查找无异于全表扫描。

2) 频繁更新的字段不要使用索引

比如logincount登录次数，频繁变化导致索引也频繁变化，增大数据库工作量，降低效率。

3) 字段不在where语句出现时不要添加索引,如果where后含IS NULL /IS NOT NULL/ like ‘%输入符%’等条件，不建议使用索引

只有在where语句出现，mysql才会去使用索引

#### 什么情况下不推荐使用索引？

1) 数据唯一性差（一个字段的取值只有几种时）的字段不要使用索引

> 比如性别，只有两种可能数据。意味着索引的二叉树级别少，多是平级。这样的二叉树查找无异于全表扫描。

2）频繁更新的字段不要使用索引

> 比如logincount登录次数，频繁变化导致索引也频繁变化，增大数据库工作量，降低效率。

3) 字段不在where语句出现时不要添加索引,如果where后含IS NULL /IS NOT NULL/ like ‘%输入符%’等条件，不建议使用索引

> 只有在where语句出现，mysql才会去使用索引

4） where 子句里对索引列使用不等于（<>），使用索引效果一般

#### IOC和AOP
**IOC（DI）**

控制反转：原来是自己主动去new一个对象去用，现在是由容器工具配置文件创建实例让自己用，以前是自己去找妹子亲近，现在是有中介帮你找妹子，让你去挑选，说白了就是用面向接口编程和配置文件减少对象间的耦合，同时解决硬编码的问题（XML）

依赖注入：在运行过程中当你需要这个对象才给你实例化并注入其中，不需要管什么时候注入的，只需要写好成员变量和set方法

**AOP**

介绍

面向切面的编程，是一种编程技术，是OOP（面向对象编程）的补充和完善。OOP的执行是一种从上往下的流程，并没有从左到右的关系。因此在OOP编程中，会有大量的重复代码。而AOP则是将这些与业务无关的重复代码抽取出来，然后再嵌入到业务代码当中。常见的应用有：权限管理、日志、事务管理等。

实现方式

实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。Spring AOP实现用的是动态代理的方式。

### java加载器类型

#### 启动（Bootstrap）类加载器

启动类加载器主要加载的是JVM自身需要的类，这个类加载使用C++语言实现的

#### 扩展（Extension）类加载器
扩展类加载器是指Sun公司(已被Oracle收购)实现的sun.misc.Launcher$ExtClassLoader类

#### 系统（System）类加载器
也称应用程序加载器是指 Sun公司实现的sun.misc.Launcher$AppClassLoader

#### 双亲委派模式工作原理
双亲委派模式要求除了顶层的启动类加载器外，其余的类加载器都应当由自己的父类加载器来进行加载。

####双亲委派模型的原因

因为如果用不同的加载器来加载同一个class文件，调用他们的equals方法，可能会得到无法确定的结果，因此需要双亲委派模型

#### 双亲委派模型的破坏

举个例子，driver接口定义在jdk中，对各个数据库厂商，他们都定义了自己的数据库连接类，需要数据库连接的时候，就需要由子类加载器来加载，此时就需要破坏双亲委派模型。打破方法是：重写classloader的loadclass方法。

### classnotfoundError
什么时候会抛出classnotfoundException异常呢？

这涉及到底层的API。当程序试图使用class类中的forname方法、classloader类中的findsystemclass方法，classloader类中loadclass方法通过字符串名的形式加载此类时，会抛出该异常
解决方案

 1. 首先检查一下你的环境变量classpath的配置，看一看所需要的支持类库是否放在类路径里面
 2. 类名错了，在调用class类中的forname方法时会出异常，很明显，我的是在调用classloader的loadclass方法时出错

### NoSuchMethodError
在Java项目开发时一般会使用maven作为项目jar包依赖管理工具，但随着工程依赖的jar包越来越多，“jar包冲突”这个潜在隐患随时可能爆发出来。大部分情况下，我们都会见到“java.lang.NoSuchMethodError”异常信息，这种情况一般都是由于包冲突引起的，如果熟悉了的话处理起来也是有法可循的，下面本文介绍一下常用方法和步骤。

### 垃圾回收器种类
Java有四种类型的垃圾回收器：

串行垃圾回收器（Serial Garbage Collector）
并行垃圾回收器（Parallel Garbage Collector）
并发标记扫描垃圾回收器（CMS Garbage Collector）
G1垃圾回收器（G1 Garbage Collector）

#### 红黑树定义

1. 结点是红色或黑色
2. 根结点始终是黑色
3. 叶子结点（NIL 结点）都是黑色
4. 红色结点的两个直接孩子结点都是黑色（即从叶子到根的所有路径上不存在两个连续的红色结点）
5. 从任一结点到每个叶子的所有简单路径都包含相同数目的黑色结点

#### 为什么hashmap线程不安全

两个不安全的要点：

1. put函数，两个线程同时put的时候，会丢失一个数据；

2. resize函数，大小超过阈值的时候，扩容，新建一个更大的数组，将原来的数据复制到新数组中。因为是数组中的元素是链表，复制之后顺序改变，而如果两个线程同时复制，那么将一会变正，一会变反，形成死锁。

#### 手写LRU算法

```java
import java.util.LinkedHashMap;

public class LRU<K, V> {
    private static final float hashLoadFactory = 0.75f;
    private LinkedHashMap<K, V> map;
    private int cacheSize;

    public LRU(int cacheSize) {
        this.cacheSize = cacheSize;
        int capicity = (int) Math.ceil(cacheSize / hashLoadFactory) + 1;
        this.map = new LinkedHashMap<K, V>(capicity, hashLoadFactory, true) {

            @Override
            protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
                return size() > LRU.this.cacheSize;
            }
        };
    }

    public synchronized V get(K key) {
        return this.map.get(key);
    }

    public synchronized void put(K key, V value) {
        this.map.put(key, value);
    }

    public synchronized void clear() {
        this.map.clear();
    }

    public synchronized int size() {
        return this.map.size();
    }
}

```

#### 一致性hash

redis集群，假如现在有2000w条数据，你有8台服务器，组成组从复制（将主服务器数据复制到从服务器，所有增删改操作在主服务器，读操作在从服务器，这样能减轻主服务器压力，也只用给远端暴露从服务器，增强安全性）的四组(每组两台)，你通过hash算法，这样可以快速找到哪个数据存在哪个服务器上。

但是现在比如你多了一组服务器，原本的hash结果对4求余(hash(key)%4)，现在的hash结果对5求余，那所有数据的hash值都变了，全部要重新放一遍，效率很低。

这时就需要一致性hash算法，假设整个hash值空间为0-2^32-1，我将这个范围连成一个环。对每个主机hash后放到环上，一个元素该放到哪个主机，就是hash结果顺时针方向走过的第一个主机节点，如下图所示。

![](https://github-blog-1255346696.cos.ap-beijing.myqcloud.com/20190326120000.png)

当新增一个节点比如Node X，假如增加到了B和C之间，那么受到影响的元素只有原先在C的元素

又比如C节点坏了，那么就把c节点所有元素复制到D就行了。如下图

![](https://github-blog-1255346696.cos.ap-beijing.myqcloud.com/20190326120228.png)

一致性hash有个问题就是假如两个节点hash值在环上距离太近，那么会造成不平衡的问题。解决办法是增加虚拟节点，一个节点多次hash，放到环上，这样就消除了数据不平衡的问题。

![](https://github-blog-1255346696.cos.ap-beijing.myqcloud.com/20190326120322.png)

#### 线程池参数

1. corePoolSize:核心线程数，值为每秒任务数\*每个任务耗时，设置为80%时间出现的任务书的值，比如每秒200~1000个任务，每个处理0.1秒，那么需要20~100个线程，核心线程数至少大于20，根据80%准则，设置为40

2. 队列长度：核心线程数/每个任务的时间*响应时间，例子中是40/0.1\*1=400，假设系统响应时间最多为1s

3. 最大线程数：（最大线程数-队列长度）\*每个线程花费时间，(1000-400)\*0.1=60

4. keepAliveTime:当负载降低时，如果一个空闲线程时间达到keepAliveTime，就退出

5. allowCoreThreadTimeout:默认不允许核心线程退出，设为true的时候可以退出

**线程池按以下方式执行任务**

1. 当线程数小于核心线程数时，创建线程。
2. 当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列。
3. 当线程数大于等于核心线程数，且任务队列已满
   1. 若线程数小于最大线程数，创建线程
   2. 若线程数等于最大线程数，抛出异常，拒绝任务

#### hash冲突的解决办法

1. 开放地址法：按原始数据顺序计算hash值，如果某个位置算出来已经有值了，就向后找到第一个没有值的位置放这个值
   ![](https://github-blog-1255346696.cos.ap-beijing.myqcloud.com/20190326154149.png)
2. 链地址法：数组每个位置存的都是链表，冲突的加入链表末尾
3. 再hash法：冲突就用新的hash函数计算，直到不冲突
4. 公共溢出区：如果溢出就放入公共溢出区

####CAS和ABA问题

CAS（compare and swap)：对于内存中的某一个值V，提供一个旧值A和一个新值B。如果提供的旧值V和A相等就把B写入V。这个过程是原子性的。

解决方法：

AtomicStampedReference解决aba问题，不光比较值是否相同，还比较版本号是否相同

#### 数据库引擎

**Myiasm**

MyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。不过和Innodb不同，MyIASM中存储了表的行数，于是SELECT COUNT(\*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。

**Innodb**

Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别，关于数据库事务与其隔离级别的内容请见数据库事务与其隔离级别这篇文章。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。

**总结：**

1. innodb支持四种SQL隔离，ACID四种特性，支持事物和行级锁，对于大数据一般用innodb
2. Myiasm保存了行数，seleclt count(\*)的效率比较高，更新数据需要锁定整个表。如果大量读，也可以用myiasm

#### spring boot如何启动一个项目



#### aop底层实现

#### 数据库分页

#### 数据库索引失效

#### redis分布式锁

#### java获取系统时间

#### 时间的格式化方法

calendar库和date库，格式化方法是simpledateFormat(format和parse函数)或者string.format("%tY")

#### 序列化反序列化



#### 线程共享变量

因为java对共享变量的读写需要从主存中复制到工作内存中成为副本，更改之后再从工作内存复制到主存中，如果多个线程对共享变量进行更改，需要保证更改后及时更新到主存，其他线程能够及时从主存中读取新的变量值更新到工作内存中。这就要求可见性。实现方式有synchronized 和 volatile 以及 java.concurrent.automic

**volatile适用情况**

a.对变量的写入操作不依赖当前值

比如自增自减、number = number + 5等（不满足）

b.当前volatile变量不依赖于别的volatile变量

比如 volatile_var > volatile_var2这个不等式（不满足）



**synchronized和volatile比较**

a. volatile不需要同步操作，所以效率更高，不会阻塞线程，但是适用情况比较窄

b. volatile读变量相当于加锁（即进入synchronized代码块），而写变量相当于解锁（退出synchronized代码块）

c. synchronized既能保证共享变量可见性，也可以保证锁内操作的原子性；volatile只能保证可见性



#### java内存模型



#### ReentrantLock实现原理



#### AQS底层原理



#### 加锁会带来哪些性能问题。如何解决？



#### NginX如何做负载均衡、常见的负载均衡算法有哪些



#### 出现 OOM 后你会怎么排查问题？



#### 操作系统的内存管理机制



#### 说下你对线程安全的理解



#### 哈夫曼编码是怎么回事