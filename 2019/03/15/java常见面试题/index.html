<!doctype html>



  


<html class="theme-next mist use-motion" lang="default">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="java," />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.0" />






<meta name="description" content="1. 面向对象特征">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="java常见面试题">
<meta property="og:url" content="http://drawwon.github.io/2019/03/15/java常见面试题/index.html">
<meta property="og:site_name" content="WangZhao&#39;s Blog">
<meta property="og:description" content="1. 面向对象特征">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-03-19T08:22:27.669Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java常见面试题">
<meta name="twitter:description" content="1. 面向对象特征">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://drawwon.github.io/2019/03/15/java常见面试题/"/>





  <title> java常见面试题 | WangZhao's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">WangZhao's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">It's not who you are underneath,it's what you do that defines you</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://drawwon.github.io/2019/03/15/java常见面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeffrey Pacino">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WangZhao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                java常见面试题
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-15T10:40:55+08:00">
                2019-03-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工作/" itemprop="url" rel="index">
                    <span itemprop="name">工作</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="1-面向对象特征"><a href="#1-面向对象特征" class="headerlink" title="1. 面向对象特征"></a>1. 面向对象特征</h4><a id="more"></a>
<p>封装，继承，多态和抽象</p>
<ol>
<li>封装<br>封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改<br>变它内部的数据。在 Java 当中，有 3 种修饰符： public， private 和 protected。每一种修饰符<br>给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。<br>下面列出了使用封装的一些好处：<ul>
<li>通过隐藏对象的属性来保护对象内部的状态。</li>
<li>提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。</li>
<li>禁止对象之间的不良交互提高模块化</li>
</ul>
</li>
<li>继承：给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用性，也可以在不修改类的情况下给现存的类添加新特性。</li>
<li>多态：是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作可以应用到其他类型的值上面。</li>
<li>抽象：是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。 Java 支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。</li>
</ol>
<h4 id="2-final-finally-finalize-的区别"><a href="#2-final-finally-finalize-的区别" class="headerlink" title="2. final, finally, finalize 的区别"></a>2. final, finally, finalize 的区别</h4><ol>
<li>final修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载。</li>
<li>finally在异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。</li>
<li>finalize方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。</li>
</ol>
<h4 id="3-int-和-Integer-有什么区别"><a href="#3-int-和-Integer-有什么区别" class="headerlink" title="3. int 和 Integer 有什么区别"></a>3. int 和 Integer 有什么区别</h4><p>int 是基本数据类型<br>Integer是其包装类，注意是一个类。<br>为什么要提供包装类呢？？？<br>一是为了在各种类型间转化，通过各种方法的调用。否则 你无法直接通过变量转化。<br>比如，现在int要转为String</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">String result=Integer.toString(a);</span><br></pre></td></tr></table></figure>
<p>在java中包装类，比较多的用途是用在于各种数据类型的转化中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num=Integer.valueOf(<span class="string">"12"</span>);<span class="comment">// 返回包装类型</span></span><br><span class="line"><span class="keyword">int</span> num2=Integer.parseInt(<span class="string">"12"</span>); <span class="comment">//返回基本数据类型</span></span><br></pre></td></tr></table></figure>
<p>再举例下。比如我现在要用泛型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; nums;</span><br></pre></td></tr></table></figure>
<p>这里&lt;&gt;需要类。如果你用int。它会报错的。</p>
<h4 id="4-重载和重写的区别"><a href="#4-重载和重写的区别" class="headerlink" title="4. 重载和重写的区别"></a>4. 重载和重写的区别</h4><p><strong>override（重写）</strong></p>
<ol>
<li><p>方法名、参数、返回值相同。</p>
</li>
<li><p>子类方法不能缩小父类方法的访问权限。</p>
</li>
<li><p>子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。</p>
</li>
<li><p>存在于父类和子类之间。</p>
</li>
<li><p>方法被定义为final不能被重写。</p>
</li>
</ol>
<p><strong>overload（重载）</strong></p>
<ol>
<li><p>参数类型、个数、顺序至少有一个不相同。</p>
</li>
<li><p>不能重载只有返回值不同的方法名。</p>
</li>
<li><p>存在于父类和子类、同类中。</p>
</li>
</ol>
<h4 id="5-抽象类和接口有什么区别"><a href="#5-抽象类和接口有什么区别" class="headerlink" title="5. 抽象类和接口有什么区别"></a>5. 抽象类和接口有什么区别</h4><p>总结：接口没有私有变量，接口可以用于实现多继承，实现接口必须实现所有其中定义的方法</p>
<p>接口是公开的，里面不能有私有的方法或变量，是用于让别人使用的，而抽象类是可以有私有方法或私有变量的，<br>另外，实现接口的一定要实现接口里定义的所有方法，而实现抽象类可以有选择地重写需要用到的方法，一般的应用里，最顶级的是接口，然后是抽象类实现接口，最后才到具体类实现。<br>还有，接口可以实现多重继承，而一个类只能继承一个超类，但可以通过继承多个接口实现多重继承，接口还有标识（里面没有任何方法，如Remote接口）和数据共享（里面的变量全是常量）的作用。</p>
<h4 id="6-说说反射的用途及实现"><a href="#6-说说反射的用途及实现" class="headerlink" title="6. 说说反射的用途及实现"></a>6. 说说反射的用途及实现</h4><p>Java 反射机制在程序<strong>运行时</strong>，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 <strong>动态的获取信息</strong> 以及 <strong>动态调用对象的方法</strong> 的功能称为 <strong>java 的反射机制</strong>。</p>
<p>Java反射机制主要提供了以下功能：在运行时构造一个类的对象；判断一个类所具有的成员变量和方法；调用一个对象的方法；生成动态代理。反射最大的应用就是框架</p>
<p>Java反射的主要功能：</p>
<ul>
<li>确定一个对象的类</li>
<li>取出类的modifiers,数据成员,方法,构造器,和超类.</li>
<li>找出某个接口里定义的常量和方法说明.</li>
<li>创建一个类实例,这个实例在运行时刻才有名字(运行时间才生成的对象).</li>
<li>取得和设定对象数据成员的值,如果数据成员名是运行时刻确定的也能做到.</li>
<li>在运行时刻调用动态对象的方法.</li>
<li>创建数组,数组大小和类型在运行时刻才确定,也能更改数组成员的值.</li>
</ul>
<p>反射的应用很多，很多框架都有用到</p>
<p>spring 的 ioc/di 也是反射….<br>javaBean和jsp之间调用也是反射….<br>struts的 FormBean 和页面之间…也是通过反射调用….<br>JDBC 的 classForName()也是反射…..<br>hibernate的 find(Class clazz) 也是反射….</p>
<p>反射还有一个不得不说的问题，就是性能问题，大量使用反射系统性能大打折扣。怎么使用使你的系统达到最优就看你系统架构和综合使用问题啦，这里就不多说了。</p>
<h4 id="7-HTTP-请求的-GET-与-POST-方式的区别"><a href="#7-HTTP-请求的-GET-与-POST-方式的区别" class="headerlink" title="7. HTTP 请求的 GET 与 POST 方式的区别"></a>7. HTTP 请求的 GET 与 POST 方式的区别</h4><p>GET方法会把名值对追加在请求的URL后面。因为URL对字符数目有限制，进而限制了用在客户端请求的参数值的数目。并且请求中的参数值是可见的，因此，敏感信息不能用这种方式传递。</p>
<p>POST方法通过把请求参数值放在请求体中来克服GET方法的限制，因此，可以发送的参数的数目是没有限制的。最后，通过POST请求传递的敏感信息对外部客户端是不可见的。</p>
<p>具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案</p>
<h4 id="8-cookie-和session-的区别："><a href="#8-cookie-和session-的区别：" class="headerlink" title="8.cookie 和session 的区别："></a>8.cookie 和session 的区别：</h4><p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</p>
<p>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗<br>   考虑到安全应当使用session。</p>
<p>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能<br>   考虑到减轻服务器性能方面，应当使用COOKIE。</p>
<p>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p>
<p>5、所以个人建议：<br>   将登陆信息等重要信息存放为SESSION<br>   其他信息如果需要保留，可以放在COOKIE中</p>
<h4 id="JDBC-流程"><a href="#JDBC-流程" class="headerlink" title="JDBC 流程"></a>JDBC 流程</h4><p><strong>1、 加载JDBC驱动程序：</strong><br>在连接数据库之前，首先要加载想要连接的数据库的驱动到JVM（Java虚拟机），<br>这通过java.lang.Class类的静态方法forName(String className)实现。</p>
<p><strong>2、 提供JDBC连接的URL</strong></p>
<ul>
<li>连接URL定义了连接数据库时的协议、子协议、数据源标识。</li>
<li>书写形式：协议：子协议：数据源标识</li>
</ul>
<p>协议：在JDBC中总是以jdbc开始 子协议：是桥连接的驱动程序或是数据库管理系统名称。<br>数据源标识：标记找到数据库来源的地址与连接端口。</p>
<p><strong>3、创建数据库的连接</strong></p>
<ul>
<li>要连接数据库，需要向java.sql.DriverManager请求并获得Connection对象， 该对象就代表一个数据库的连接。</li>
<li>使用DriverManager的getConnectin(String url , String username , String password )方法传入指定的欲连接的数据库的路径、数据库的用户名和 密码来获得。</li>
</ul>
<p><strong>4、 创建一个Statement</strong></p>
<p>要执行SQL语句，必须获得java.sql.Statement实例，Statement实例分为以下3 种类型：<br>1、执行静态SQL语句。通常通过Statement实例实现。<br>2、执行动态SQL语句。通常通过PreparedStatement实例实现。<br>3、执行数据库存储过程。通常通过CallableStatement实例实现。</p>
<p><strong>5、执行SQL语句</strong><br>Statement接口提供了三种执行SQL语句的方法：executeQuery 、executeUpdate 和execute<br>1、ResultSet executeQuery(String sqlString)：执行查询数据库的SQL语句 ，返回一个结果集（ResultSet）对象。<br>2、int executeUpdate(String sqlString)：用于执行INSERT、UPDATE或 DELETE语句以及SQL DDL语句，如：CREATE TABLE和DROP TABLE等<br>3、execute(sqlString):用于执行返回多个结果集、多个更新计数或二者组合的 语句。 具体实现的代码：</p>
<p>6、处理结果<br>两种情况：<br>1、执行更新返回的是本次操作影响到的记录数。<br>2、执行查询返回的结果是一个ResultSet对象。</p>
<p>7、关闭JDBC对象<br>操作完成以后要把所有使用的JDBC对象全都关闭，以释放JDBC资源，关闭顺序和声 明顺序相反：<br>1、关闭记录集<br>2、关闭声明<br>3、关闭连接对象</p>
<h4 id="MVC-设计思想"><a href="#MVC-设计思想" class="headerlink" title="MVC 设计思想"></a>MVC 设计思想</h4><p>MVC就是<br>M:Model 模型<br>V:View 视图<br>C:Controller 控制器<br>模型就是封装业务逻辑和数据的一个一个的模块,控制器就是调用这些模块的(java中通常是用Servlet来实现,框架的话很多是用Struts2来实现这一层),视图就主要是你看到的,比如JSP等.<br>当用户发出请求的时候,控制器根据请求来选择要处理的业务逻辑和要选择的数据,再返回去把结果输出到视图层,这里可能是进行重定向或转发等.</p>
<h4 id="equals-与-的区别"><a href="#equals-与-的区别" class="headerlink" title="equals 与 == 的区别"></a>equals 与 == 的区别</h4><p>值类型（int,char,long,boolean等）都是用==判断相等性。对象引用的话，==判断引用所指的对象是否是同一个。</p>
<p>equals是Object的成员函数，有些类会覆盖（override）这个方法，用于判断对象的等价性。例如String类，两个引用所指向的String都是”abc”，但可能出现他们实际对应的对象并不是同一个（和jvm实现方式有关），因此用==判断他们可能不相等，但用equals判断一定是相等的。</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="List-和-Set-区别"><a href="#List-和-Set-区别" class="headerlink" title="List 和 Set 区别"></a>List 和 Set 区别</h4><p>List,Set都是继承自Collection接口</p>
<p>List特点：元素有放入顺序，元素可重复</p>
<p>Set特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉</p>
<p>（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的，加入Set 的Object必须定义equals()方法 ，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。）</p>
<p>Set和List对比：</p>
<p>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。</p>
<p>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。</p>
<h4 id="List-和-Map-区别"><a href="#List-和-Map-区别" class="headerlink" title="List 和 Map 区别"></a>List 和 Map 区别</h4><p>List是对象集合，允许对象重复。</p>
<p>Map是键值对的集合，不允许key重复。</p>
<h4 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别"></a>Arraylist 与 LinkedList 区别</h4><p><strong>Arraylist</strong>：</p>
<p>优点：ArrayList是实现了基于动态数组的数据结构,因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。</p>
<p>缺点：因为地址连续， ArrayList要移动数据，所以插入和删除操作效率比较低。</p>
<p><strong>LinkedList</strong>：</p>
<p>优点：LinkedList基于链表的数据结构,地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址，对于新增和删除操作add和remove，LinedList比较占优势。LinkedList 适用于要头尾操作或插入指定位置的场景</p>
<p>缺点：因为LinkedList要移动指针,所以查询操作性能比较低。</p>
<p><strong>适用场景分析：</strong></p>
<p>当需要对数据进行顺序访问的情况下选用ArrayList，当需要对数据进行多次增加删除修改时采用LinkedList。</p>
<h4 id="ArrayList-与-Vector-区别"><a href="#ArrayList-与-Vector-区别" class="headerlink" title="ArrayList 与 Vector 区别"></a>ArrayList 与 Vector 区别</h4><p>ArrayList和Vector都是用数组实现的，主要有这么三个区别：</p>
<ol>
<li>Vector是多线程安全的，线程安全就是说多线程访问同一代码，不会产生不确定的结果。而ArrayList不是，这个可以从源码中看出，Vector类中的方法很多有synchronized进行修饰，这样就导致了Vector在效率上无法与ArrayList相比；</li>
<li>两个都是采用的线性连续空间存储元素，但是当空间不足的时候，两个类的增加方式是不同。</li>
<li>Vector可以设置增长因子，而ArrayList不可以。</li>
<li>Vector是一种老的动态数组，是线程同步的，效率很低，一般不赞成使用。</li>
</ol>
<p><strong>适用场景分析</strong>：</p>
<ol>
<li>Vector是线程同步的，所以它也是线程安全的，而ArrayList是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用ArrayList效率比较高。</li>
<li>如果集合中的元素的数目大于目前集合数组的长度时，在集合中使用数据量比较大的数据，用Vector有一定的优势。</li>
</ol>
<h4 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h4><p>1.hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和containsKey（）方法。</p>
<p>2.hashTable同步的，而HashMap是非同步的，效率上比hashTable要高。</p>
<p>3.hashMap允许空键值，而hashTable不允许。</p>
<p>注意：TreeMap：非线程安全基于红黑树实现。TreeMap没有调优选项，因为该树总处于平衡状态。</p>
<p>Treemap：适用于按自然顺序或自定义顺序遍历键(key)。</p>
<h4 id="HashSet-和-HashMap-区别"><a href="#HashSet-和-HashMap-区别" class="headerlink" title="HashSet 和 HashMap 区别"></a>HashSet 和 HashMap 区别</h4><p>set是线性结构，set中的值不能重复，hashset是set的hash实现，hashset中值不能重复是用hashmap的key来实现的。</p>
<p>map是键值对映射，可以空键空值。HashMap是Map接口的hash实现，key的唯一性是通过key值hash值的唯一来确定，value值是则是链表结构。</p>
<p>他们的共同点都是hash算法实现的唯一性，他们都不能持有基本类型，只能持有对象</p>
<h4 id="HashMap-和-ConcurrentHashMap-的区别"><a href="#HashMap-和-ConcurrentHashMap-的区别" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别"></a>HashMap 和 ConcurrentHashMap 的区别</h4><p>ConcurrentHashMap是线程安全的HashMap的实现。</p>
<p>（1）ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的syn关键字锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。</p>
<p>（2）HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</p>
<h4 id="ConcurrentHashMap-的工作原理及代码实现"><a href="#ConcurrentHashMap-的工作原理及代码实现" class="headerlink" title="ConcurrentHashMap 的工作原理及代码实现"></a>ConcurrentHashMap 的工作原理及代码实现</h4><p>HashTable里使用的是synchronized关键字，这其实是对对象加锁，锁住的都是对象整体，当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。</p>
<p>ConcurrentHashMap引入了分割(Segment)，在put方法中，会根据hash(paramK.hashCode())来决定具体存放进哪个Segment，如果查看Segment的put操作，我们会发现内部使用的同步机制是基于lock操作的，这样就可以对Map的一部分（Segment）进行上锁，这样影响的只是将要放入同一个Segment的元素的put操作，保证同步的时候，锁住的不是整个Map（HashTable就是这么做的），相对于HashTable提高了多线程环境下的性能，因此HashTable已经被淘汰了。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="创建线程的方式及实现"><a href="#创建线程的方式及实现" class="headerlink" title="创建线程的方式及实现"></a>创建线程的方式及实现</h4><p>Java中创建线程主要有三种方式：</p>
<p><strong>一、继承Thread类创建线程类</strong></p>
<p>（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。</p>
<p>（2）创建Thread子类的实例，即创建了线程对象。</p>
<p>（3）调用线程对象的start()方法来启动该线程。</p>
<p><strong>二、通过Runnable接口创建线程类</strong></p>
<p>（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</p>
<p>（2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</p>
<p>（3）调用线程对象的start()方法来启动该线程。</p>
<p><strong>三、通过Callable和FutureTask创建线程</strong></p>
<p>（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</p>
<p>（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。</p>
<p>（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。</p>
<p>（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p>
<p><strong>创建线程的三种方式的对比</strong></p>
<p>采用实现Runnable、Callable接口的方式创见多线程时，优势是：</p>
<p>线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。</p>
<p>在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</p>
<p>劣势是：</p>
<p>编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。</p>
<p>使用继承Thread类的方式创建多线程时优势是：</p>
<p>编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。</p>
<p>劣势是：</p>
<p>线程类已经继承了Thread类，所以不能再继承其他父类。</p>
<h4 id="sleep-、join（）、yield（）有什么区别"><a href="#sleep-、join（）、yield（）有什么区别" class="headerlink" title="sleep() 、join（）、yield（）有什么区别"></a>sleep() 、join（）、yield（）有什么区别</h4><p><strong>1、sleep()方法</strong></p>
<p>在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。 让其他线程有机会继续执行，但它并不释放对象锁。也就是如果有Synchronized同步块，其他线程仍然不能访问共享数据。注意该方法要捕获异常</p>
<p>比如有两个线程同时执行(没有Synchronized)，一个线程优先级为MAX_PRIORITY，另一个为MIN_PRIORITY，如果没有Sleep()方法，只有高优先级的线程执行完成后，低优先级的线程才能执行；但当高优先级的线程sleep(5000)后，低优先级就有机会执行了。总之，sleep()可以使低优先级的线程得到执行的机会，当然也可以让同优先级、高优先级的线程有执行的机会。</p>
<p><strong>2、yield()方法</strong></p>
<p>yield()方法和sleep()方法类似，也不会释放“锁标志”，区别在于，它没有参数，即yield()方法只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行，另外yield()方法只能使同优先级或者高优先级的线程得到执行机会，这也和sleep()方法不同。</p>
<p><strong>线程的sleep()方法和yield()方法有什么区别？</strong></p>
<p>答： ① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会； ② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态； ③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常； ④ sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。</p>
<p><strong>3、join()方法</strong></p>
<p>Thread的非静态方法join()让一个线程B“加入”到另外一个线程A的尾部。在A执行完毕之前，B不能工作。</p>
<h4 id="讲讲线程池的实现原理"><a href="#讲讲线程池的实现原理" class="headerlink" title="讲讲线程池的实现原理"></a>讲讲线程池的实现原理</h4><p>主要是ThreadPoolExecutor的实现原理，在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。</p>
<h4 id="线程池的几种方式"><a href="#线程池的几种方式" class="headerlink" title="线程池的几种方式"></a>线程池的几种方式</h4><p>newFixedThreadPool(int nThreads)<br>创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程</p>
<p>newCachedThreadPool()<br>创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制</p>
<p>newSingleThreadExecutor()<br>这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行</p>
<p>newScheduledThreadPool(int corePoolSize)<br>创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。</p>
<h4 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h4><p>新建(New)、就绪（Runnable）、运行（Running）、 阻塞(Blocked)和死亡(Dead)5种状态</p>
<p>(1)生命周期的五种状态</p>
<p><strong>新建（new Thread）</strong><br>当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。<br>例如：Thread t1=new Thread();</p>
<p><strong>就绪（runnable）</strong><br>线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源。例如：t1.start();</p>
<p><strong>运行（running）</strong><br>线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。</p>
<p><strong>死亡（dead）</strong><br>当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。</p>
<p>自然终止：正常运行run()方法后终止</p>
<p>异常终止：调用stop()方法让一个线程终止运行</p>
<p><strong>堵塞（blocked）</strong><br>由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。</p>
<p>正在睡眠：用sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。</p>
<p>正在等待：调用wait()方法。（调用motify()方法回到就绪状态）</p>
<p>被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复）</p>
<h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><h4 id="说说线程安全问题"><a href="#说说线程安全问题" class="headerlink" title="说说线程安全问题"></a>说说线程安全问题</h4><p>线程安全是指要控制多个线程对某个资源的有序访问或修改，而在这些线程之间没有产生冲突。<br>在Java里，线程安全一般体现在两个方面：<br>1、多个thread对同一个java实例的访问（read和modify）不会相互干扰。</p>
<p>它主要体现在关键字synchronized。如ArrayList和Vector，HashMap和Hashtable（后者每个方法前都有synchronized关键字）。如果你在interator一个List对象时，其它线程remove一个element，问题就出现了。<br>2、每个线程都有自己的字段，而不会在多个线程之间共享。</p>
<p>它主要体现在java.lang.ThreadLocal类，而没有Java关键字支持，如像static、transient那样。</p>
<h4 id="悲观锁-乐观锁"><a href="#悲观锁-乐观锁" class="headerlink" title="悲观锁 乐观锁"></a>悲观锁 乐观锁</h4><p>乐观锁 悲观锁是一种思想。可以用在很多方面。</p>
<p>比如数据库方面。<br>悲观锁就是for update（锁定查询的行）<br>乐观锁就是 version字段（比较跟上一次的版本号，如果一样则更新，如果失败则要重复读-比较-写的操作。）</p>
<p>JDK方面：<br>悲观锁就是sync<br>乐观锁就是原子类（内部使用CAS实现）</p>
<p>本质来说，就是悲观锁认为总会有人抢我的。乐观锁就认为，基本没人抢。</p>
<h4 id="CAS-乐观锁"><a href="#CAS-乐观锁" class="headerlink" title="CAS 乐观锁"></a>CAS 乐观锁</h4><p>乐观锁是一种思想，即认为读多写少，遇到并发写的可能性比较低，所以采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。</p>
<p>CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。CAS顶多算是乐观锁写那一步操作的一种实现方式罢了，不用CAS自己加锁也是可以的。</p>
<h4 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h4><p>ABA：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A，当前线程的CAS操作无法分辨当前V值是否发生过变化。</p>
<p>乐观锁（Optimistic Lock）：每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。</p>
<p>乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。</p>
<h4 id="1-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"><a href="#1-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？" class="headerlink" title="1.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"></a>1.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</h4><p>Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。Java 源文件被编译成能被 Java 虚拟机执行的字节码文件。</p>
<p> Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。</p>
<p> Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</p>
<h4 id="2-JDK和JRE的区别是什么？"><a href="#2-JDK和JRE的区别是什么？" class="headerlink" title="2.JDK和JRE的区别是什么？"></a>2.JDK和JRE的区别是什么？</h4><p>JDK: java开发工具包,包含了JRE、编译器和其它工具（如：javaDOc、java调试器)</p>
<p>JRE: java运行环境,包含java虚拟机和java程序所需的核心类库。</p>
<p>如果只是想跑java程序，那么只需安装JRE，如果要写java程序并且运行，那就需要JDK了。</p>
<h4 id="3-”static”关键字是什么意思？Java中是否可以覆盖一个private或者是static的方法？"><a href="#3-”static”关键字是什么意思？Java中是否可以覆盖一个private或者是static的方法？" class="headerlink" title="3.”static”关键字是什么意思？Java中是否可以覆盖一个private或者是static的方法？"></a>3.”static”关键字是什么意思？Java中是否可以覆盖一个private或者是static的方法？</h4><p>如果一个类的变量或者方法前面有<strong>static</strong>修饰，那么表明这个方法或者变量属于这个类，也就是说可以在不创建对象的情况下直接使用</p>
<p> 当父类的方法被<strong>private</strong>修饰时，表明该方法为父类私有，对其他任何类都是不可见的，因此如果子类定了一个与父类一样的方法，这对于子类来说相当于是一个新的私有方法，且如果要进行向上转型，然后去调用该“覆盖方法”，会产生编译错误</p>
<h4 id="4-Java支持的基本数据类型有哪些？什么是自动拆装箱？"><a href="#4-Java支持的基本数据类型有哪些？什么是自动拆装箱？" class="headerlink" title="4.Java支持的基本数据类型有哪些？什么是自动拆装箱？"></a>4.Java支持的基本数据类型有哪些？什么是自动拆装箱？</h4><p>java支持的基本数据类型有以下9种:byte,shot,int,long,float,double,char,boolean,void.</p>
<p>自动拆装箱是java从jdk1.5引用，目的是将原始类型自动的装换为相对应的对象，也可以逆向进行，即拆箱。这也体现java中一切皆对象的宗旨。</p>
<p>所谓自动装箱就是将原始类型自动的转换为对应的对象，而拆箱就是将对象类型转换为基本类型。java中的自动拆装箱通常发生在变量赋值的过程中。</p>
<h4 id="5-重写和重载是什么"><a href="#5-重写和重载是什么" class="headerlink" title="5. 重写和重载是什么?"></a>5. 重写和重载是什么?</h4><p><strong>重写</strong>，发生在子类与父类之间，表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。</p>
<p><strong>重载</strong>是指在一个类中，可以有多个相同名称的方法，但是他们的参数列表的个数或类型不同，当调用该方法时，根据传递的参数类型调用对应参数列表的方法。当参数列表相同但返回值不同时，将会出现编译错误，这并不是重载，因为jvm无法根据返回值类型来判断应该调用哪个方法。</p>
<h4 id="6-Java支持多继承么？如果不支持，如何实现"><a href="#6-Java支持多继承么？如果不支持，如何实现" class="headerlink" title="6.Java支持多继承么？如果不支持，如何实现?"></a>6.Java支持多继承么？如果不支持，如何实现?</h4><p>在java中是单继承的，也就是说一个类只能继承一个父类。</p>
<p>java中实现多继承有两种方式,一是接口，而是内部类.</p>
<h3 id="7-什么是值传递和引用传递？java中是值传递还是引用传递，还是都有"><a href="#7-什么是值传递和引用传递？java中是值传递还是引用传递，还是都有" class="headerlink" title="7.什么是值传递和引用传递？java中是值传递还是引用传递，还是都有?"></a>7.什么是值传递和引用传递？java中是值传递还是引用传递，还是都有?</h3><p><strong>值传递</strong> 就是在方法调用的时候，实参是将自己的一份拷贝赋给形参，在方法内，对该参数值的修改不影响原来实参，常见的例子就是刚开始学习c语言的时候那个交换方法的例子了。</p>
<p><strong>引用传递</strong> 是在方法调用的时候，实参将自己的地址传递给形参，此时方法内对该参数值的改变，就是对该实参的实际操作。</p>
<p>在java中基本数据类型的传递是值传递，对象的传递是引用传递</p>
<h4 id="8-接口和抽象类的区别是什么"><a href="#8-接口和抽象类的区别是什么" class="headerlink" title="8.接口和抽象类的区别是什么?"></a>8.接口和抽象类的区别是什么?</h4><p>区别：</p>
<ol>
<li><p>接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。</p>
</li>
<li><p>类可以实现很多个接口，但是只能继承一个抽象类</p>
</li>
<li><p>类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。</p>
</li>
<li><p>抽象类可以在不提供接口方法实现的情况下实现接口。</p>
</li>
<li><p>Java 接口中声明的变量默认都是 final 的。抽象类可以包含非 final 的变量。</p>
</li>
<li><p>Java 接口中的成员函数默认是 public 的。抽象类的成员函数可以是 private，protected 或者是 public 。</p>
</li>
<li><p>接口是绝对抽象的，不可以被实例化(java 8已支持在接口中实现默认的方法)。抽象类也不可以被实例化，但是，如果它包含 main 方法的话是可以被调用的。</p>
</li>
</ol>
<h4 id="9-构造器（constructor）是否可被重写（override）"><a href="#9-构造器（constructor）是否可被重写（override）" class="headerlink" title="9.构造器（constructor）是否可被重写（override）?"></a>9.构造器（constructor）是否可被重写（override）?</h4><p>构造方法不能被子类继承，所以是不能被子类重写的，但是构造方法可以重载，也就是说一个类可以有多个构造方法。</p>
<h4 id="10-Math-round-11-5-等于多少-Math-round-11-5-等于多少"><a href="#10-Math-round-11-5-等于多少-Math-round-11-5-等于多少" class="headerlink" title="10.Math.round(11.5) 等于多少? Math.round(-11.5)等于多少?"></a>10.Math.round(11.5) 等于多少? Math.round(-11.5)等于多少?</h4><p>Math.round(11.5)==12 Math.round(-11.5)==-11 round 方法返回与参数 最接近的长整数，参数加 1/2 后求其 floor.</p>
<h3 id="11-String-StringBuffer-StringBuilder的区别。"><a href="#11-String-StringBuffer-StringBuilder的区别。" class="headerlink" title="11. String, StringBuffer StringBuilder的区别。"></a>11. String, StringBuffer StringBuilder的区别。</h3><p>String 的长度是不可变的；</p>
<p>StringBuffer的长度是可变的，如果你对字符串中的内容经常进行操作，特别是内容要修改时，那么使用 StringBuffer，如果最后需要 &gt;String，那么使用 StringBuffer 的 toString() 方法；线程安全；</p>
<p>StringBuilder 是从 JDK 5 开始，为StringBuffer该类补充了一个单个线程使用的等价类；通常应该优先使用 StringBuilder 类，因为它支持所有相同的操作，但由于它不执行同步，所以速度更快。<br>使用字符串的时候要特别小心，如果对一个字符串要经常改变的话，就一定不要用String,否则会创建许多无用的对象出来.</p>
<h4 id="12-JVM内存分哪几个区，每个区的作用是什么"><a href="#12-JVM内存分哪几个区，每个区的作用是什么" class="headerlink" title="12.JVM内存分哪几个区，每个区的作用是什么?"></a>12.JVM内存分哪几个区，每个区的作用是什么?</h4><p>java虚拟机主要分为以下五个区: 方虚本程堆</p>
<p><strong>方法区：</strong></p>
<ol>
<li>有时候也称为<strong>永久代</strong>，在该区内很少发生垃圾回收，但是并不代表不发生GC，在这里进行的GC主要是对方法区里的常量池和对类型的卸载</li>
<li>方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。</li>
<li>该区域是被线程共享的。</li>
<li>方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。</li>
</ol>
<p><strong>虚拟机栈:</strong></p>
<ol>
<li>虚拟机栈也就是我们平常所称的<strong>栈内存</strong>,它为java方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。</li>
<li>虚拟机栈是线程私有的，它的生命周期与线程相同。</li>
<li>局部变量表里存储的是基本数据类型、returnAddress类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定</li>
<li>操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式</li>
<li>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接.动态链接就是将常量池中的符号引用在运行期转化为直接引用。</li>
</ol>
<p><strong>本地方法栈</strong></p>
<p>本地方法栈和虚拟机栈类似，只不过本地方法栈为Native方法服务。</p>
<p><strong>堆</strong></p>
<p> java堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作。</p>
<p><strong>程序计数器</strong></p>
<p>内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内存区域是唯一一个java虚拟机规范没有规定任何out of memory情况的区域。</p>
<h3 id="13-如和判断一个对象是否存活-或者GC对象的判定方法"><a href="#13-如和判断一个对象是否存活-或者GC对象的判定方法" class="headerlink" title="13.如和判断一个对象是否存活?(或者GC对象的判定方法)"></a>13.如和判断一个对象是否存活?(或者GC对象的判定方法)</h3><p>判断一个对象是否存活有两种方法:</p>
<p> <strong>引用计数法</strong></p>
<p>所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收.</p>
<p>引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象A引用对象B，对象B又引用者对象A，那么此时A,B对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。</p>
<p>2.<strong>可达性算法</strong>(引用链法)</p>
<p>该算法的思想是：从一个被称为<strong>GC Roots</strong>的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。</p>
<p>在java中可以作为GC Roots的对象有以下几种:</p>
<p>虚拟机栈中引用的对象<br>方法区类静态属性引用的对象<br>方法区常量池引用的对象<br>本地方法栈JNI引用的对象</p>
<h3 id="14-简述java垃圾回收机制"><a href="#14-简述java垃圾回收机制" class="headerlink" title="14.简述java垃圾回收机制?"></a>14.简述java垃圾回收机制?</h3><p>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p>
<h3 id="15-java中垃圾回收的方法有哪些"><a href="#15-java中垃圾回收的方法有哪些" class="headerlink" title="15.java中垃圾回收的方法有哪些?"></a>15.java中垃圾回收的方法有哪些?</h3><ol>
<li><p><strong>标记-清除:</strong></p>
<p> 这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想就是标记哪些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题：1.效率不高，标记和清除的效率都很低；2.会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次GC动作。</p>
</li>
<li><p><strong>复制算法:</strong></p>
<p> 为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。但是这种方式，内存的代价太高，每次基本上都要浪费一般的内存。</p>
<p> 于是将该算法进行了改进，内存区域不再是按照1：1去划分，而是将内存划分为8:1:1三部分，较大那份内存交Eden区，其余是两块较小的内存区叫Survior区。每次都会优先使用Eden区，若Eden区满，就将对象复制到第二块内存区上，然后清除Eden区，如果此时存活的对象太多，以至于Survivor不够时，会将这些对象通过分配担保机制复制到老年代中。(java堆又分为新生代和老年代)</p>
</li>
<li><p><strong>标记-整理</strong></p>
<p> 该算法主要是为了解决标记-清除，产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候先将可回收对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。</p>
</li>
</ol>
<ol>
<li><p><strong>分代收集</strong> </p>
<p>  现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用<strong>复制</strong>算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用<strong>标记-整理</strong> 或者 <strong>标记-清除</strong>。</p>
</li>
</ol>
<h4 id="16-java内存模型"><a href="#16-java内存模型" class="headerlink" title="16.java内存模型"></a>16.java内存模型</h4><p>java内存模型(JMM)是线程间通信的控制机制.JMM定义了主内存和线程之间抽象关系。线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java内存模型的抽象示意图如下：</p>
<h4 id="17-java类加载过程"><a href="#17-java类加载过程" class="headerlink" title="17.java类加载过程?"></a>17.java类加载过程?</h4><p> java类加载需要经历以下5个过程：加验准解初</p>
<p><strong>加载（通过名字获取类并生成class文件），</strong></p>
<p><strong>验证（保证字节流不危害到虚拟机），</strong></p>
<p><strong>准备（为静态变量分配内存），</strong></p>
<p><strong>解析（符号引用变为直接引用），</strong></p>
<p><strong>初始化（之前的都由虚拟机控制，这一步才真正执行类中的java代码）</strong></p>
<p> <strong>加载</strong></p>
<p> 加载时类加载的第一个过程，在这个阶段，将完成一下三件事情：</p>
<ol>
<li><p>通过一个类的全限定名获取该类的二进制流。</p>
</li>
<li><p>将该二进制流中的静态存储结构转化为方法去运行时数据结构。</p>
</li>
<li><p>在内存中生成该类的Class对象，作为该类的数据访问入口。</p>
<p><strong>验证</strong></p>
</li>
</ol>
<p>验证的目的是为了确保Class文件的字节流中的信息不会危害到虚拟机.在该阶段主要完成以下四钟验证:</p>
<ol>
<li><p>文件格式验证：验证字节流是否符合Class文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型.</p>
</li>
<li><p>元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。</p>
</li>
<li><p>字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。</p>
</li>
<li><p>符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。</p>
<p><strong>准备</strong></p>
</li>
</ol>
<p>准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p>
<p><strong>解析</strong> </p>
<p>该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。</p>
<p><strong>初始化</strong></p>
<p>初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。</p>
<h4 id="18-简述java类加载机制"><a href="#18-简述java类加载机制" class="headerlink" title="18.简述java类加载机制?"></a>18.简述java类加载机制?</h4><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的java类型。</p>
<h4 id="19-类加载器双亲委派模型机制？"><a href="#19-类加载器双亲委派模型机制？" class="headerlink" title="19.类加载器双亲委派模型机制？"></a>19.类加载器双亲委派模型机制？</h4><p>当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。</p>
<h3 id="20-什么是类加载器，类加载器有哪些"><a href="#20-什么是类加载器，类加载器有哪些" class="headerlink" title="20.什么是类加载器，类加载器有哪些?"></a>20.什么是类加载器，类加载器有哪些?</h3><p>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。</p>
<p>主要有一下四种类加载器:</p>
<ol>
<li>启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。</li>
<li><p>扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</p>
</li>
<li><p>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</p>
</li>
<li>用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。</li>
</ol>
<h3 id="21-简述java内存分配与回收策率以及Minor-GC和Major-GC"><a href="#21-简述java内存分配与回收策率以及Minor-GC和Major-GC" class="headerlink" title="21.简述java内存分配与回收策率以及Minor GC和Major GC"></a><strong>21.简述java内存分配与回收策率以及Minor GC和Major GC</strong></h3><ol>
<li><p>对象优先在堆的Eden区分配。</p>
</li>
<li><p>大对象直接进入老年代.</p>
</li>
<li><p>长期存活的对象将直接进入老年代.</p>
</li>
</ol>
<p>当Eden区没有足够的空间进行分配时，虚拟机会执行一次Minor GC.Minor Gc通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生Gc的频率较高，回收速度比较快;Full Gc/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC,但是通过配置，可以在Full GC之前进行一次Minor GC这样可以加快老年代的回收速度。</p>
<h3 id="22-HashMap的工作原理是什么"><a href="#22-HashMap的工作原理是什么" class="headerlink" title="22.HashMap的工作原理是什么?"></a><strong>22.HashMap的工作原理是什么?</strong></h3><p>HashMap内部是通过一个数组实现的，只是这个数组比较特殊，数组里存储的元素是一个Entry实体(jdk 8为Node)，这个Entry实体主要包含key、value以及一个指向自身的next指针。HashMap是基于hashing实现的，当我们进行put操作时，根据传递的key值得到它的hashcode，然后再用这个hashcode与数组的长度进行模运算，得到一个int值，就是Entry要存储在数组的位置（下标）；当通过get方法获取指定key的值时，会根据这个key算出它的hash值（数组下标），根据这个hash值获取数组下标对应的Entry，然后判断Entry里的key，hash值或者通过equals()比较是否与要查找的相同，如果相同，返回value，否则的话，遍历该链表（有可能就只有一个Entry，此时直接返回null），直到找到为止，否则返回null。</p>
<p>HashMap之所以在每个数组元素存储的是一个链表，是为了解决hash冲突问题，当两个对象的hash值相等时，那么一个位置肯定是放不下两个值的，于是hashmap采用链表来解决这种冲突，hash值相等的两个元素会形成一个链表。</p>
<h3 id="23-HashMap与HashTable的区别是什么"><a href="#23-HashMap与HashTable的区别是什么" class="headerlink" title="23.HashMap与HashTable的区别是什么?"></a><strong>23.HashMap与HashTable的区别是什么?</strong></h3><ol>
<li><p>HashTable基于Dictionary类，而HashMap是基于AbstractMap。Dictionary是任何可将键映射到相应值的类的抽象父类，而AbstractMap是基于Map接口的实现，它以最大限度地减少实现此接口所需的工作。</p>
</li>
<li><p>HashMap的key和value都允许为null，而Hashtable的key和value都不允许为null。HashMap遇到key为null的时候，调用putForNullKey方法进行处理，而对value没有处理；Hashtable遇到null，直接返回NullPointerException。</p>
</li>
<li><p>Hashtable是同步的，而HashMap是非同步的，但是我们也可以通过Collections.synchronizedMap(hashMap),使其实现同步。</p>
</li>
</ol>
<h3 id="24-CorrentHashMap的工作原理"><a href="#24-CorrentHashMap的工作原理" class="headerlink" title="24.CorrentHashMap的工作原理?"></a>24.CorrentHashMap的工作原理?</h3><p><strong>jdk 1.6版:</strong> ConcurrenHashMap可以说是HashMap的升级版，ConcurrentHashMap是线程安全的，但是与Hashtablea相比，实现线程安全的方式不同。Hashtable是通过对hash表结构进行锁定，是阻塞式的，当一个线程占有这个锁时，其他线程必须阻塞等待其释放锁。ConcurrentHashMap是采用分离锁的方式，它并没有对整个hash表进行锁定，而是局部锁定，也就是说当一个线程占有这个局部锁时，不影响其他线程对hash表其他地方的访问。</p>
<p>具体实现:ConcurrentHashMap内部有一个Segment<k,v>数组,该Segment对象可以充当锁。Segment对象内部有一个HashEntry<k,v>数组，于是每个Segment可以守护若干个桶(HashEntry),每个桶又有可能是一个HashEntry连接起来的链表，存储发生碰撞的元素。</k,v></k,v></p>
<p> 每个ConcurrentHashMap在默认并发级下会创建包含16个Segment对象的数组，每个数组有若干个桶，当我们进行put方法时，通过hash方法对key进行计算，得到hash值，找到对应的segment，然后对该segment进行加锁，然后调用segment的put方法进行存储操作，此时其他线程就不能访问当前的segment，但可以访问其他的segment对象，不会发生阻塞等待。</p>
<p> <strong>jdk 1.8版</strong> 在jdk 8中，ConcurrentHashMap不再使用Segment分离锁，而是采用一种乐观锁CAS算法来实现同步问题，但其底层还是“数组+链表-&gt;红黑树”的实现。</p>
<h3 id="27-Array和ArrayList有何区别？什么时候更适合用Array？"><a href="#27-Array和ArrayList有何区别？什么时候更适合用Array？" class="headerlink" title="27.Array和ArrayList有何区别？什么时候更适合用Array？"></a>27.Array和ArrayList有何区别？什么时候更适合用Array？</h3><ol>
<li><p>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。</p>
</li>
<li><p>Array是指定大小的，而ArrayList大小是固定的</p>
</li>
</ol>
<h3 id="28-哪些集合类提供对元素的随机访问？"><a href="#28-哪些集合类提供对元素的随机访问？" class="headerlink" title="28.哪些集合类提供对元素的随机访问？"></a>28.哪些集合类提供对元素的随机访问？</h3><p>ArrayList、HashMap、TreeMap和HashTable类提供对元素的随机访问。</p>
<h3 id="29-HashSet的底层实现是什么"><a href="#29-HashSet的底层实现是什么" class="headerlink" title="29.HashSet的底层实现是什么?"></a>29.HashSet的底层实现是什么?</h3><p>通过看源码知道HashSet的实现是依赖于HashMap的，HashSet的值都是存储在HashMap中的。在HashSet的构造法中会初始化一个HashMap对象，HashSet不允许值重复，因此，HashSet的值是作为HashMap的key存储在HashMap中的，当存储的值已经存在时返回false。</p>
<h3 id="30-LinkedHashMap的实现原理"><a href="#30-LinkedHashMap的实现原理" class="headerlink" title="30.LinkedHashMap的实现原理?"></a>30.LinkedHashMap的实现原理?</h3><p>LinkedHashMap也是基于HashMap实现的，不同的是它定义了一个Entry header，这个header不是放在Table里，它是额外独立出来的。LinkedHashMap通过继承hashMap中的Entry,并添加两个属性Entry before,after,和header结合起来组成一个双向链表，来实现按插入顺序或访问顺序排序。LinkedHashMap定义了排序模式accessOrder，该属性为boolean型变量，对于访问顺序，为true；对于插入顺序，则为false。一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。</p>
<h3 id="33-Thread-类中的start-和-run-方法有什么区别？"><a href="#33-Thread-类中的start-和-run-方法有什么区别？" class="headerlink" title="33.Thread 类中的start() 和 run() 方法有什么区别？"></a>33.Thread 类中的start() 和 run() 方法有什么区别？</h3><p>start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。</p>
<h3 id="35-Java中有哪几种锁"><a href="#35-Java中有哪几种锁" class="headerlink" title="35.Java中有哪几种锁?"></a>35.Java中有哪几种锁?</h3><p><strong>自旋锁:</strong> 自旋锁在JDK1.6之后就默认开启了。基于之前的观察，共享数据的锁定状态只会持续很短的时间，为了这一小段时间而去挂起和恢复线程有点浪费，所以这里就做了一个处理，让后面请求锁的那个线程在稍等一会，但是不放弃处理器的执行时间，看看持有锁的线程能否快速释放。为了让线程等待，所以需要让线程执行一个忙循环也就是自旋操作。</p>
<p>在jdk6之后，引入了自适应的自旋锁，也就是等待的时间不再固定了，而是由上一次在同一个锁上的自旋时间及锁的拥有者状态来决定</p>
<p><strong>偏向锁:</strong> 在JDK1.之后引入的一项锁优化，目的是消除数据在无竞争情况下的同步原语。进一步提升程序的运行性能。 偏向锁就是偏心的偏，意思是这个锁会偏向第一个获得他的线程，如果接下来的执行过程中，该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。偏向锁可以提高带有同步但无竞争的程序性能，也就是说他并不一定总是对程序运行有利，如果程序中大多数的锁都是被多个不同的线程访问，那偏向模式就是多余的，在具体问题具体分析的前提下，可以考虑是否使用偏向锁。</p>
<p><strong>轻量级锁:</strong> 为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</p>
<h3 id="37-ThreadLocal理解"><a href="#37-ThreadLocal理解" class="headerlink" title="37.ThreadLocal理解"></a>37.ThreadLocal理解</h3><p>ThreadLocal是一个创建——线程局部变量的类。通常情况下我们创建的变量,可以被多个线程访问并修改，通过ThreadLocal创建的变量只能被当前线程访问。</p>
<p><strong>ThreadLocal内部实现</strong></p>
<p>ThreadLocal提供了set和get方法.<br> set方法会先获取当前线程,然后用当前线程作为句柄,获取ThreadLocaMap对象,并判断该对象是否为空,如果为空则创建一个,并设置值,不为空则直接设置值。</p>
<h4 id="38-synchronized和lock的区别？"><a href="#38-synchronized和lock的区别？" class="headerlink" title="38. synchronized和lock的区别？"></a>38. synchronized和lock的区别？</h4><ul>
<li>主要相同点：Lock能完成synchronized所实现的所有功能。</li>
<li>主要不同点：Lock有比synchronized更精确的线程予以和更好的性能。</li>
</ul>
<ol>
<li>synchronized会自动释放锁，但是Lock一定要求程序员手工释放，并且必须在finally从句中释放。</li>
<li>synchronized修饰方法时,表示同一个对象在不同的线程中,表现为同步队列,如果实例化不同的对象,那么synchronized就不会出现同步效果了。</li>
</ol>
<h4 id="39-单例模式"><a href="#39-单例模式" class="headerlink" title="39. 单例模式"></a>39. 单例模式</h4><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 </p>
<h4 id="40-数据库的四种隔离等级"><a href="#40-数据库的四种隔离等级" class="headerlink" title="40.数据库的四种隔离等级"></a>40.数据库的四种隔离等级</h4><ul>
<li><p>未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据</p>
</li>
<li><p>提交读(Read Committed)：只限制同一数据写事务禁止其它读写事务。解决”脏读”和”更新丢失”。Oracle等多数数据库默认都是该级别 (不重复读)</p>
</li>
<li><p>可重复读(Repeated Read)：可重复读。限制同一数据写事务禁止其他读写事务，读事务禁止其它写事务(允许读)。InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读</p>
</li>
<li><p>串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞</p>
</li>
</ul>
<p><strong>① 脏读:</strong> 脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</p>
<p><strong>②不可重复读</strong>：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。</p>
<p><strong>④ 幻读:</strong>事务 T1 读取一条指定的 Where 子句所返回的结果集，然后 T2 事务新插入一行记录，这行记录恰好可以满足T1 所使用的查询条件。然后 T1 再次对表进行检索，但又看到了 T2 插入的数据。 （和可重复读类似，但是事务 T2 的数据操作仅仅是插入和删除，不是修改数据，读取的记录数量前后不一致）</p>
<h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><h4 id="是否可以在static环境中访问非static变量？"><a href="#是否可以在static环境中访问非static变量？" class="headerlink" title="是否可以在static环境中访问非static变量？"></a>是否可以在static环境中访问非static变量？</h4><p>static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</p>
<h4 id="Java支持的数据类型有哪些？什么是自动拆装箱？"><a href="#Java支持的数据类型有哪些？什么是自动拆装箱？" class="headerlink" title="Java支持的数据类型有哪些？什么是自动拆装箱？"></a>Java支持的数据类型有哪些？什么是自动拆装箱？</h4><p>Java语言支持的8种基本数据类型是：</p>
<p>byte、short、int、long、float、double、boolean、char</p>
<p>自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。</p>
<h4 id="概括的解释下线程的几种可用状态。线程状态"><a href="#概括的解释下线程的几种可用状态。线程状态" class="headerlink" title="概括的解释下线程的几种可用状态。线程状态"></a>概括的解释下线程的几种可用状态。线程状态</h4><ol>
<li>新建</li>
<li>可运行：新建后调用了start方法，放入线程池等待调度，获取cpu使用权</li>
<li>运行：可运行的线程获取了cpu时间片</li>
<li>阻塞：线程因某种原因放弃了cpu时间片<br>1）同步阻塞：因为没有获取到同步锁而阻塞<br>2）等待阻塞：调用了wait方法，等待notify方法解出阻塞状态<br>3）其他阻塞：sleep方法之类的，等sleep超时之后恢复</li>
<li>死亡：run结束，或异常退出run，死亡不可再生</li>
</ol>
<h4 id="同步方法和同步代码块的区别是什么？"><a href="#同步方法和同步代码块的区别是什么？" class="headerlink" title="同步方法和同步代码块的区别是什么？"></a>同步方法和同步代码块的区别是什么？</h4><p>同步方法默认用this或者当前类class对象作为锁；</p>
<p>同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；</p>
<p>同步方法使用关键字 synchronized修饰方法，而同步代码块主要是修饰需要进行同步的代码，用   synchronized（object）{代码内容}进行修饰；</p>
<h4 id="在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？"><a href="#在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？" class="headerlink" title="在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？"></a>在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</h4><p>监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。</p>
<h4 id="什么是死锁-deadlock-？"><a href="#什么是死锁-deadlock-？" class="headerlink" title="什么是死锁(deadlock)？"></a>什么是死锁(deadlock)？</h4><p><strong>死锁</strong> <strong>:</strong>是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种<strong>互相等待</strong>的现象,若无<strong>外力</strong>作用,它们都将无法推进下去</p>
<p>（1） <strong>互斥条件</strong>：一个资源每次只能被一个进程使用。  </p>
<p>（2） <strong>请求与保持条件</strong>：一个进程因请求资源而阻塞时，对已获得的资源保持不放。  </p>
<p>（3） <strong>不可抢占</strong>:进程已获得的资源，在末使用完之前，不能强行剥夺。  </p>
<p>（4） <strong>循环等待</strong>:有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</p>
<h4 id="如何确保N个线程可以访问N个资源同时又不导致死锁？"><a href="#如何确保N个线程可以访问N个资源同时又不导致死锁？" class="headerlink" title="如何确保N个线程可以访问N个资源同时又不导致死锁？"></a>如何确保N个线程可以访问N个资源同时又不导致死锁？</h4><p>使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。</p>
<h4 id="快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><a href="#快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？" class="headerlink" title="快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？"></a>快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</h4><p>一：快速失败（fail—fast）</p>
<p>在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的结构进行了修改（增加、删除），则会抛出Concurrent Modification Exception。</p>
<p>原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果结构发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p>
<p>注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。</p>
<p>​      场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。</p>
<p>​    二：安全失败（fail—safe）</p>
<p>​      采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p>
<p>​      原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</p>
<p>​      缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p>
<p>​          场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p>
<h4 id="数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用Array而不是ArrayList？"><a href="#数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用Array而不是ArrayList？" class="headerlink" title="数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？"></a>数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？</h4><ol>
<li>Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。</li>
<li>Array大小是固定的，ArrayList的大小是动态变化的。</li>
<li>ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。<br>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</li>
</ol>
<h4 id="什么是优先级队列"><a href="#什么是优先级队列" class="headerlink" title="什么是优先级队列"></a>什么是优先级队列</h4><p>优先级队列中的元素可以按照任意的顺序插入，却总是按照排序的顺序进行检索。无论何时调用remove方法，总会获得当前优先级队列中的最小元素，但并不是对所有元素都排序。它是采用了堆（一个可以自我调整的二叉树），执行增加删除操作后，可以让最小元素移动到根。</p>
<h4 id="串行-serial-收集器和吞吐量-throughput-收集器的区别是什么？"><a href="#串行-serial-收集器和吞吐量-throughput-收集器的区别是什么？" class="headerlink" title="串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？"></a>串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？</h4><p>吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。而串行收集器对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。</p>
<h4 id="数据库四个特性"><a href="#数据库四个特性" class="headerlink" title="数据库四个特性"></a>数据库四个特性</h4><ol>
<li>原子性（Atomicity）</li>
</ol>
<p>　　原子性是指事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败。比如在同一个事务中的SQL语句，要么全部执行成功，要么全部执行失败。</p>
<p>　　回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p>
<ol>
<li>一致性（Consistency）</li>
</ol>
<p>　　事务必须使数据库从一个一致性状态变换到另外一个一致性状态。以转账为例子，A向B转账，假设转账之前这两个用户的钱加起来总共是2000，那么A向B转账之后，不管这两个账户怎么转，A用户的钱和B用户的钱加起来的总额还是2000，这个就是事务的一致性。</p>
<ol>
<li>隔离性（Isolation）</li>
</ol>
<p>　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
<p>　　即要达到这么一种效果：对于任意两个并发的事务 T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p>
<ol>
<li>持久性（Durability）</li>
</ol>
<p>　　一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p>
<p>　　可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。</p>
<p>什么情况下不推荐使用索引？<br>1) 数据唯一性差（一个字段的取值只有几种时）的字段不要使用索引</p>
<p>比如性别，只有两种可能数据。意味着索引的二叉树级别少，多是平级。这样的二叉树查找无异于全表扫描。</p>
<p>2) 频繁更新的字段不要使用索引</p>
<p>比如logincount登录次数，频繁变化导致索引也频繁变化，增大数据库工作量，降低效率。</p>
<p>3) 字段不在where语句出现时不要添加索引,如果where后含IS NULL /IS NOT NULL/ like ‘%输入符%’等条件，不建议使用索引</p>
<p>只有在where语句出现，mysql才会去使用索引</p>
<h4 id="什么情况下不推荐使用索引？"><a href="#什么情况下不推荐使用索引？" class="headerlink" title="什么情况下不推荐使用索引？"></a>什么情况下不推荐使用索引？</h4><p>1) 数据唯一性差（一个字段的取值只有几种时）的字段不要使用索引</p>
<blockquote>
<p>比如性别，只有两种可能数据。意味着索引的二叉树级别少，多是平级。这样的二叉树查找无异于全表扫描。</p>
</blockquote>
<p>2）频繁更新的字段不要使用索引</p>
<blockquote>
<p>比如logincount登录次数，频繁变化导致索引也频繁变化，增大数据库工作量，降低效率。</p>
</blockquote>
<p>3) 字段不在where语句出现时不要添加索引,如果where后含IS NULL /IS NOT NULL/ like ‘%输入符%’等条件，不建议使用索引</p>
<blockquote>
<p>只有在where语句出现，mysql才会去使用索引</p>
</blockquote>
<p>4） where 子句里对索引列使用不等于（&lt;&gt;），使用索引效果一般</p>
<h4 id="IOC和AOP"><a href="#IOC和AOP" class="headerlink" title="IOC和AOP"></a>IOC和AOP</h4><p><strong>IOC（DI）</strong></p>
<p>控制反转：原来是自己主动去new一个对象去用，现在是由容器工具配置文件创建实例让自己用，以前是自己去找妹子亲近，现在是有中介帮你找妹子，让你去挑选，说白了就是用面向接口编程和配置文件减少对象间的耦合，同时解决硬编码的问题（XML）</p>
<p>依赖注入：在运行过程中当你需要这个对象才给你实例化并注入其中，不需要管什么时候注入的，只需要写好成员变量和set方法</p>
<p><strong>AOP</strong></p>
<p>介绍</p>
<p>面向切面的编程，是一种编程技术，是OOP（面向对象编程）的补充和完善。OOP的执行是一种从上往下的流程，并没有从左到右的关系。因此在OOP编程中，会有大量的重复代码。而AOP则是将这些与业务无关的重复代码抽取出来，然后再嵌入到业务代码当中。常见的应用有：权限管理、日志、事务管理等。</p>
<p>实现方式</p>
<p>实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。Spring AOP实现用的是动态代理的方式。</p>
<h3 id="java加载器类型"><a href="#java加载器类型" class="headerlink" title="java加载器类型"></a>java加载器类型</h3><h4 id="启动（Bootstrap）类加载器"><a href="#启动（Bootstrap）类加载器" class="headerlink" title="启动（Bootstrap）类加载器"></a>启动（Bootstrap）类加载器</h4><p>启动类加载器主要加载的是JVM自身需要的类，这个类加载使用C++语言实现的</p>
<h4 id="扩展（Extension）类加载器"><a href="#扩展（Extension）类加载器" class="headerlink" title="扩展（Extension）类加载器"></a>扩展（Extension）类加载器</h4><p>扩展类加载器是指Sun公司(已被Oracle收购)实现的sun.misc.Launcher$ExtClassLoader类</p>
<h4 id="系统（System）类加载器"><a href="#系统（System）类加载器" class="headerlink" title="系统（System）类加载器"></a>系统（System）类加载器</h4><p>也称应用程序加载器是指 Sun公司实现的sun.misc.Launcher$AppClassLoader</p>
<h4 id="双亲委派模式工作原理"><a href="#双亲委派模式工作原理" class="headerlink" title="双亲委派模式工作原理"></a>双亲委派模式工作原理</h4><p>双亲委派模式要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器</p>
<h3 id="classnotfoundError"><a href="#classnotfoundError" class="headerlink" title="classnotfoundError"></a>classnotfoundError</h3><p>什么时候会抛出classnotfoundException异常呢？</p>
<p>这涉及到底层的API。当程序试图使用class类中的forname方法、classloader类中的findsystemclass方法，classloader类中loadclass方法通过字符串名的形式加载此类时，会抛出该异常<br>解决方案</p>
<ol>
<li>首先检查一下你的环境变量classpath的配置，看一看所需要的支持类库是否放在类路径里面</li>
<li>类名错了，在调用class类中的forname方法时会出异常，很明显，我的是在调用classloader的loadclass方法时出错</li>
</ol>
<h3 id="NoSuchMethodError"><a href="#NoSuchMethodError" class="headerlink" title="NoSuchMethodError"></a>NoSuchMethodError</h3><p>在Java项目开发时一般会使用maven作为项目jar包依赖管理工具，但随着工程依赖的jar包越来越多，“jar包冲突”这个潜在隐患随时可能爆发出来。大部分情况下，我们都会见到“java.lang.NoSuchMethodError”异常信息，这种情况一般都是由于包冲突引起的，如果熟悉了的话处理起来也是有法可循的，下面本文介绍一下常用方法和步骤。</p>
<h3 id="垃圾回收器种类"><a href="#垃圾回收器种类" class="headerlink" title="垃圾回收器种类"></a>垃圾回收器种类</h3><p>Java有四种类型的垃圾回收器：</p>
<p>串行垃圾回收器（Serial Garbage Collector）<br>并行垃圾回收器（Parallel Garbage Collector）<br>并发标记扫描垃圾回收器（CMS Garbage Collector）<br>G1垃圾回收器（G1 Garbage Collector）</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/09/操作系统知识点总结/" rel="next" title="操作系统知识点总结">
                <i class="fa fa-chevron-left"></i> 操作系统知识点总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Jeffrey Pacino" />
          <p class="site-author-name" itemprop="name">Jeffrey Pacino</p>
           
              <p class="site-description motion-element" itemprop="description">Humble to the dust and then out of the flowers</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">76</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">40</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">49</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/drawwon" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://wpa.qq.com/msgrd?v=3&uin=847707695&site=qq&menu=yes" target="_blank" title="QQ">
                  
                    <i class="fa fa-fw fa-qq"></i>
                  
                  QQ
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:jeffrey.pacino@gmail.com" target="_blank" title="email">
                  
                    <i class="fa fa-fw fa-paper-plane"></i>
                  
                  email
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-面向对象特征"><span class="nav-number">1.</span> <span class="nav-text">1. 面向对象特征</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-final-finally-finalize-的区别"><span class="nav-number">2.</span> <span class="nav-text">2. final, finally, finalize 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-int-和-Integer-有什么区别"><span class="nav-number">3.</span> <span class="nav-text">3. int 和 Integer 有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-重载和重写的区别"><span class="nav-number">4.</span> <span class="nav-text">4. 重载和重写的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-抽象类和接口有什么区别"><span class="nav-number">5.</span> <span class="nav-text">5. 抽象类和接口有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-说说反射的用途及实现"><span class="nav-number">6.</span> <span class="nav-text">6. 说说反射的用途及实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-HTTP-请求的-GET-与-POST-方式的区别"><span class="nav-number">7.</span> <span class="nav-text">7. HTTP 请求的 GET 与 POST 方式的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-cookie-和session-的区别："><span class="nav-number">8.</span> <span class="nav-text">8.cookie 和session 的区别：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDBC-流程"><span class="nav-number">9.</span> <span class="nav-text">JDBC 流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MVC-设计思想"><span class="nav-number">10.</span> <span class="nav-text">MVC 设计思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#equals-与-的区别"><span class="nav-number">11.</span> <span class="nav-text">equals 与 == 的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合"><span class="nav-number"></span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#List-和-Set-区别"><span class="nav-number">1.</span> <span class="nav-text">List 和 Set 区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#List-和-Map-区别"><span class="nav-number">2.</span> <span class="nav-text">List 和 Map 区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Arraylist-与-LinkedList-区别"><span class="nav-number">3.</span> <span class="nav-text">Arraylist 与 LinkedList 区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayList-与-Vector-区别"><span class="nav-number">4.</span> <span class="nav-text">ArrayList 与 Vector 区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap-和-Hashtable-的区别"><span class="nav-number">5.</span> <span class="nav-text">HashMap 和 Hashtable 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashSet-和-HashMap-区别"><span class="nav-number">6.</span> <span class="nav-text">HashSet 和 HashMap 区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap-和-ConcurrentHashMap-的区别"><span class="nav-number">7.</span> <span class="nav-text">HashMap 和 ConcurrentHashMap 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentHashMap-的工作原理及代码实现"><span class="nav-number">8.</span> <span class="nav-text">ConcurrentHashMap 的工作原理及代码实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程"><span class="nav-number"></span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建线程的方式及实现"><span class="nav-number">1.</span> <span class="nav-text">创建线程的方式及实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sleep-、join（）、yield（）有什么区别"><span class="nav-number">2.</span> <span class="nav-text">sleep() 、join（）、yield（）有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#讲讲线程池的实现原理"><span class="nav-number">3.</span> <span class="nav-text">讲讲线程池的实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程池的几种方式"><span class="nav-number">4.</span> <span class="nav-text">线程池的几种方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程的生命周期"><span class="nav-number">5.</span> <span class="nav-text">线程的生命周期</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁机制"><span class="nav-number"></span> <span class="nav-text">锁机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#说说线程安全问题"><span class="nav-number">1.</span> <span class="nav-text">说说线程安全问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#悲观锁-乐观锁"><span class="nav-number">2.</span> <span class="nav-text">悲观锁 乐观锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS-乐观锁"><span class="nav-number">3.</span> <span class="nav-text">CAS 乐观锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ABA-问题"><span class="nav-number">4.</span> <span class="nav-text">ABA 问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"><span class="nav-number">5.</span> <span class="nav-text">1.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-JDK和JRE的区别是什么？"><span class="nav-number">6.</span> <span class="nav-text">2.JDK和JRE的区别是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-”static”关键字是什么意思？Java中是否可以覆盖一个private或者是static的方法？"><span class="nav-number">7.</span> <span class="nav-text">3.”static”关键字是什么意思？Java中是否可以覆盖一个private或者是static的方法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Java支持的基本数据类型有哪些？什么是自动拆装箱？"><span class="nav-number">8.</span> <span class="nav-text">4.Java支持的基本数据类型有哪些？什么是自动拆装箱？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-重写和重载是什么"><span class="nav-number">9.</span> <span class="nav-text">5. 重写和重载是什么?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-Java支持多继承么？如果不支持，如何实现"><span class="nav-number">10.</span> <span class="nav-text">6.Java支持多继承么？如果不支持，如何实现?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-什么是值传递和引用传递？java中是值传递还是引用传递，还是都有"><span class="nav-number"></span> <span class="nav-text">7.什么是值传递和引用传递？java中是值传递还是引用传递，还是都有?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-接口和抽象类的区别是什么"><span class="nav-number">1.</span> <span class="nav-text">8.接口和抽象类的区别是什么?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-构造器（constructor）是否可被重写（override）"><span class="nav-number">2.</span> <span class="nav-text">9.构造器（constructor）是否可被重写（override）?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-Math-round-11-5-等于多少-Math-round-11-5-等于多少"><span class="nav-number">3.</span> <span class="nav-text">10.Math.round(11.5) 等于多少? Math.round(-11.5)等于多少?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-String-StringBuffer-StringBuilder的区别。"><span class="nav-number"></span> <span class="nav-text">11. String, StringBuffer StringBuilder的区别。</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#12-JVM内存分哪几个区，每个区的作用是什么"><span class="nav-number">1.</span> <span class="nav-text">12.JVM内存分哪几个区，每个区的作用是什么?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-如和判断一个对象是否存活-或者GC对象的判定方法"><span class="nav-number"></span> <span class="nav-text">13.如和判断一个对象是否存活?(或者GC对象的判定方法)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-简述java垃圾回收机制"><span class="nav-number"></span> <span class="nav-text">14.简述java垃圾回收机制?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-java中垃圾回收的方法有哪些"><span class="nav-number"></span> <span class="nav-text">15.java中垃圾回收的方法有哪些?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#16-java内存模型"><span class="nav-number">1.</span> <span class="nav-text">16.java内存模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-java类加载过程"><span class="nav-number">2.</span> <span class="nav-text">17.java类加载过程?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-简述java类加载机制"><span class="nav-number">3.</span> <span class="nav-text">18.简述java类加载机制?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-类加载器双亲委派模型机制？"><span class="nav-number">4.</span> <span class="nav-text">19.类加载器双亲委派模型机制？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-什么是类加载器，类加载器有哪些"><span class="nav-number"></span> <span class="nav-text">20.什么是类加载器，类加载器有哪些?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-简述java内存分配与回收策率以及Minor-GC和Major-GC"><span class="nav-number"></span> <span class="nav-text">21.简述java内存分配与回收策率以及Minor GC和Major GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-HashMap的工作原理是什么"><span class="nav-number"></span> <span class="nav-text">22.HashMap的工作原理是什么?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-HashMap与HashTable的区别是什么"><span class="nav-number"></span> <span class="nav-text">23.HashMap与HashTable的区别是什么?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-CorrentHashMap的工作原理"><span class="nav-number"></span> <span class="nav-text">24.CorrentHashMap的工作原理?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27-Array和ArrayList有何区别？什么时候更适合用Array？"><span class="nav-number"></span> <span class="nav-text">27.Array和ArrayList有何区别？什么时候更适合用Array？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-哪些集合类提供对元素的随机访问？"><span class="nav-number"></span> <span class="nav-text">28.哪些集合类提供对元素的随机访问？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#29-HashSet的底层实现是什么"><span class="nav-number"></span> <span class="nav-text">29.HashSet的底层实现是什么?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#30-LinkedHashMap的实现原理"><span class="nav-number"></span> <span class="nav-text">30.LinkedHashMap的实现原理?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#33-Thread-类中的start-和-run-方法有什么区别？"><span class="nav-number"></span> <span class="nav-text">33.Thread 类中的start() 和 run() 方法有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#35-Java中有哪几种锁"><span class="nav-number"></span> <span class="nav-text">35.Java中有哪几种锁?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#37-ThreadLocal理解"><span class="nav-number"></span> <span class="nav-text">37.ThreadLocal理解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#38-synchronized和lock的区别？"><span class="nav-number">1.</span> <span class="nav-text">38. synchronized和lock的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#39-单例模式"><span class="nav-number">2.</span> <span class="nav-text">39. 单例模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#40-数据库的四种隔离等级"><span class="nav-number">3.</span> <span class="nav-text">40.数据库的四种隔离等级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#倒排索引"><span class="nav-number">4.</span> <span class="nav-text">倒排索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#是否可以在static环境中访问非static变量？"><span class="nav-number">5.</span> <span class="nav-text">是否可以在static环境中访问非static变量？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java支持的数据类型有哪些？什么是自动拆装箱？"><span class="nav-number">6.</span> <span class="nav-text">Java支持的数据类型有哪些？什么是自动拆装箱？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#概括的解释下线程的几种可用状态。线程状态"><span class="nav-number">7.</span> <span class="nav-text">概括的解释下线程的几种可用状态。线程状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同步方法和同步代码块的区别是什么？"><span class="nav-number">8.</span> <span class="nav-text">同步方法和同步代码块的区别是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？"><span class="nav-number">9.</span> <span class="nav-text">在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是死锁-deadlock-？"><span class="nav-number">10.</span> <span class="nav-text">什么是死锁(deadlock)？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何确保N个线程可以访问N个资源同时又不导致死锁？"><span class="nav-number">11.</span> <span class="nav-text">如何确保N个线程可以访问N个资源同时又不导致死锁？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><span class="nav-number">12.</span> <span class="nav-text">快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用Array而不是ArrayList？"><span class="nav-number">13.</span> <span class="nav-text">数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是优先级队列"><span class="nav-number">14.</span> <span class="nav-text">什么是优先级队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#串行-serial-收集器和吞吐量-throughput-收集器的区别是什么？"><span class="nav-number">15.</span> <span class="nav-text">串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据库四个特性"><span class="nav-number">16.</span> <span class="nav-text">数据库四个特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么情况下不推荐使用索引？"><span class="nav-number">17.</span> <span class="nav-text">什么情况下不推荐使用索引？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IOC和AOP"><span class="nav-number">18.</span> <span class="nav-text">IOC和AOP</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java加载器类型"><span class="nav-number"></span> <span class="nav-text">java加载器类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#启动（Bootstrap）类加载器"><span class="nav-number">1.</span> <span class="nav-text">启动（Bootstrap）类加载器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#扩展（Extension）类加载器"><span class="nav-number">2.</span> <span class="nav-text">扩展（Extension）类加载器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#系统（System）类加载器"><span class="nav-number">3.</span> <span class="nav-text">系统（System）类加载器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#双亲委派模式工作原理"><span class="nav-number">4.</span> <span class="nav-text">双亲委派模式工作原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#classnotfoundError"><span class="nav-number"></span> <span class="nav-text">classnotfoundError</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NoSuchMethodError"><span class="nav-number"></span> <span class="nav-text">NoSuchMethodError</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收器种类"><span class="nav-number"></span> <span class="nav-text">垃圾回收器种类</span></a></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jeffrey Pacino</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>





  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

</body>
</html>
